[
  {
    "title": "AI and Developers: Another Brick or Another Floor?",
    "description": "AI will shake the market — that much is certain. Whether it walls developers in or elevates them depends on a timescale most people forget to consider.",
    "date": "2026-02-22T12:25:00.000Z",
    "author": "Josenaldo Matos",
    "category": "opinion",
    "image": "/images/blog/ai-and-developers-another-brick-or-another-floor.png",
    "body": {
      "raw": "\nI'll be honest with you from the start: I don't know what will happen.\n\nNobody does.\n\nAnyone who tells you with certainty that AI will eliminate developers — or that developers have nothing to worry about — is selling you something. Probably confidence they don't have.\n\nWhat I *can* do is look backwards. And when I do, I see a pattern that keeps repeating, wave after wave, technology after technology.\n\nThat pattern is what this article is about.\n\n---\n\n## Two Metaphors, One Conflict\n\nPink Floyd sang *\"Another Brick in the Wall\"* — a song about systems that imprison, dehumanize, flatten people into components of something that doesn't serve them.\n\nWhen I look at how AI is being deployed *today*, in a capitalist market driven by short-term results, I see that metaphor playing out in real time:\n\n* Junior developers being replaced before they ever become seniors.\n* Hiring freezes justified by \"AI can do that now.\"\n* Power concentrating in the hands of whoever controls the models.\n* Professionals — real people — absorbing the cost of a transition they didn't choose.\n\nThat's the brick.\n\nBut there's another metaphor. Software engineering is like a skyscraper under construction. Each era adds a new floor of abstraction:\n\n* Machine code. Assembly. Operating systems.\n* High-level languages. Frameworks. Cloud platforms.\n* And now: AI-assisted development.\n\nEach new floor didn't demolish what was below. It raised the building higher — and made the foundation *more* critical, not less. The higher the structure, the more pressure on the ground it stands on.\n\nThat's the floor.\n\nBoth metaphors are true. The conflict between them is the actual question.\n\n---\n\n## The Short Term Is the Brick\n\nLet's not skip past this too quickly.\n\nThe disruption is real. It's happening now. It will get worse before it stabilizes.\n\nWhen a new abstraction layer arrives this fast, the market doesn't smoothly redistribute workers — it shakes the building. People fall. Roles that existed last year disappear before new ones are clearly defined. The people who absorb the cost most aren't the ones at the top making the decisions.\n\nThis isn't pessimism. It's pattern recognition.\n\nThe cloud computing wave didn't warn sysadmins before it arrived. Mobile didn't send a memo to desktop developers. Each wave produced genuine disruption, real unemployment, real anxiety — concentrated in the people least positioned to adapt quickly.\n\nAI is doing the same thing, and it would be dishonest to pretend otherwise.\n\n---\n\n## The Long Term Is the Floor\n\nBut here's what the pattern also shows, consistently, across every technological wave:\n\n**The market eventually expands more than it contracts.**\n\nHigh-level languages didn't eliminate systems engineers — they created millions of new developers who never would have learned assembly. Frameworks didn't kill backend developers — they made it economically viable to build software that previously wouldn't have been built at all. The cloud didn't eliminate infrastructure expertise — it created an entirely new discipline, massively scaled it, and produced demand for kernel engineers that hadn't existed before.\n\nWe eliminated typists. We employed vastly more people typing.\n\nEach wave lowered the cost of creation. And because creation became cheaper, more things got created. More systems, more complexity, more edge cases, more infrastructure — and therefore, more demand for people who understand what's happening underneath.\n\nAI follows the same trajectory.\n\nIt lowers the cost of building software. That means more software will be built. More systems will interact in unexpected ways. More abstractions will leak. More performance limits will be reached. And when they do — someone will need to go downstairs.\n\nSomeone always debugs the runtime.\nSomeone investigates the memory behavior.\nSomeone reads the logs nobody else understands.\n\nHigher abstraction doesn't reduce the need for expertise. It creates demand for deeper expertise.\n\n---\n\n## The Real Question Isn't \"Will AI Replace Developers?\"\n\nThat's the wrong question.\n\nThe right question is: **how long does the brick phase last before the floor phase begins?**\n\nBecause both are coming. The brick is here now. The floor is being built underneath us whether we acknowledge it or not.\n\nAnd between those two phases — in the transition, in the turbulence — is where careers are won or lost. Where some people fall off the building and others figure out which floor they're building next.\n\n---\n\n## How to Survive the Wave When It's Your Side That's Threatened\n\nI don't have a formula. But I can share what the pattern suggests.\n\n**Don't mistake the wave for the ocean.**\n\nThe wave is violent and disorienting. It feels like destruction. But waves move through the water — they don't replace it. The underlying dynamics of software complexity, the need for people who understand systems, the value of judgment over mere execution — those don't disappear. They become more scarce, and therefore more valuable.\n\n**Understand the floor below you.**\n\nEvery new abstraction creates distance from the layers underneath. The developers who survive transitions — and who gain leverage in the new world — are the ones who can go downstairs when the abstraction fails. Knowing *why* something works is more durable than knowing *how* to operate a tool that might not exist next year.\n\n**Position yourself at the boundary.**\n\nThe most valuable place in any technological transition isn't at the old layer or the new one — it's at the boundary between them. Understanding how AI tools work, where they fail, how they compose with existing systems, what they can't reason about — that's where judgment lives. And judgment doesn't get automated easily.\n\n**Acknowledge the cost of transition — in yourself and in others.**\n\nIf you're in a position of privilege in this wave — senior, established, with runway — use it to help people who aren't. The expansion of the market is not evenly distributed. Mentorship, advocacy, honest writing about what's actually happening: these matter.\n\n---\n\n## The Building Keeps Growing\n\nI can't tell you when the brick phase ends. I can't tell you exactly what the new floor looks like, or what your role will be on it.\n\nWhat I can tell you is this: every previous wave that felt like the end of software development turned out to be the beginning of a larger one. The building didn't fall — it grew taller. And a taller building needs more engineers, not fewer.\n\nAI is not the end of programming.\n\nIt's another floor in a building that has been under construction for decades.\n\nThe question isn't whether you'll have a place in it.\n\nThe question is which floor you'll choose to build.\n",
      "html": "<p>I'll be honest with you from the start: I don't know what will happen.</p>\n<p>Nobody does.</p>\n<p>Anyone who tells you with certainty that AI will eliminate developers — or that developers have nothing to worry about — is selling you something. Probably confidence they don't have.</p>\n<p>What I <em>can</em> do is look backwards. And when I do, I see a pattern that keeps repeating, wave after wave, technology after technology.</p>\n<p>That pattern is what this article is about.</p>\n<hr>\n<h2>Two Metaphors, One Conflict</h2>\n<p>Pink Floyd sang <em>\"Another Brick in the Wall\"</em> — a song about systems that imprison, dehumanize, flatten people into components of something that doesn't serve them.</p>\n<p>When I look at how AI is being deployed <em>today</em>, in a capitalist market driven by short-term results, I see that metaphor playing out in real time:</p>\n<ul>\n<li>Junior developers being replaced before they ever become seniors.</li>\n<li>Hiring freezes justified by \"AI can do that now.\"</li>\n<li>Power concentrating in the hands of whoever controls the models.</li>\n<li>Professionals — real people — absorbing the cost of a transition they didn't choose.</li>\n</ul>\n<p>That's the brick.</p>\n<p>But there's another metaphor. Software engineering is like a skyscraper under construction. Each era adds a new floor of abstraction:</p>\n<ul>\n<li>Machine code. Assembly. Operating systems.</li>\n<li>High-level languages. Frameworks. Cloud platforms.</li>\n<li>And now: AI-assisted development.</li>\n</ul>\n<p>Each new floor didn't demolish what was below. It raised the building higher — and made the foundation <em>more</em> critical, not less. The higher the structure, the more pressure on the ground it stands on.</p>\n<p>That's the floor.</p>\n<p>Both metaphors are true. The conflict between them is the actual question.</p>\n<hr>\n<h2>The Short Term Is the Brick</h2>\n<p>Let's not skip past this too quickly.</p>\n<p>The disruption is real. It's happening now. It will get worse before it stabilizes.</p>\n<p>When a new abstraction layer arrives this fast, the market doesn't smoothly redistribute workers — it shakes the building. People fall. Roles that existed last year disappear before new ones are clearly defined. The people who absorb the cost most aren't the ones at the top making the decisions.</p>\n<p>This isn't pessimism. It's pattern recognition.</p>\n<p>The cloud computing wave didn't warn sysadmins before it arrived. Mobile didn't send a memo to desktop developers. Each wave produced genuine disruption, real unemployment, real anxiety — concentrated in the people least positioned to adapt quickly.</p>\n<p>AI is doing the same thing, and it would be dishonest to pretend otherwise.</p>\n<hr>\n<h2>The Long Term Is the Floor</h2>\n<p>But here's what the pattern also shows, consistently, across every technological wave:</p>\n<p><strong>The market eventually expands more than it contracts.</strong></p>\n<p>High-level languages didn't eliminate systems engineers — they created millions of new developers who never would have learned assembly. Frameworks didn't kill backend developers — they made it economically viable to build software that previously wouldn't have been built at all. The cloud didn't eliminate infrastructure expertise — it created an entirely new discipline, massively scaled it, and produced demand for kernel engineers that hadn't existed before.</p>\n<p>We eliminated typists. We employed vastly more people typing.</p>\n<p>Each wave lowered the cost of creation. And because creation became cheaper, more things got created. More systems, more complexity, more edge cases, more infrastructure — and therefore, more demand for people who understand what's happening underneath.</p>\n<p>AI follows the same trajectory.</p>\n<p>It lowers the cost of building software. That means more software will be built. More systems will interact in unexpected ways. More abstractions will leak. More performance limits will be reached. And when they do — someone will need to go downstairs.</p>\n<p>Someone always debugs the runtime.\nSomeone investigates the memory behavior.\nSomeone reads the logs nobody else understands.</p>\n<p>Higher abstraction doesn't reduce the need for expertise. It creates demand for deeper expertise.</p>\n<hr>\n<h2>The Real Question Isn't \"Will AI Replace Developers?\"</h2>\n<p>That's the wrong question.</p>\n<p>The right question is: <strong>how long does the brick phase last before the floor phase begins?</strong></p>\n<p>Because both are coming. The brick is here now. The floor is being built underneath us whether we acknowledge it or not.</p>\n<p>And between those two phases — in the transition, in the turbulence — is where careers are won or lost. Where some people fall off the building and others figure out which floor they're building next.</p>\n<hr>\n<h2>How to Survive the Wave When It's Your Side That's Threatened</h2>\n<p>I don't have a formula. But I can share what the pattern suggests.</p>\n<p><strong>Don't mistake the wave for the ocean.</strong></p>\n<p>The wave is violent and disorienting. It feels like destruction. But waves move through the water — they don't replace it. The underlying dynamics of software complexity, the need for people who understand systems, the value of judgment over mere execution — those don't disappear. They become more scarce, and therefore more valuable.</p>\n<p><strong>Understand the floor below you.</strong></p>\n<p>Every new abstraction creates distance from the layers underneath. The developers who survive transitions — and who gain leverage in the new world — are the ones who can go downstairs when the abstraction fails. Knowing <em>why</em> something works is more durable than knowing <em>how</em> to operate a tool that might not exist next year.</p>\n<p><strong>Position yourself at the boundary.</strong></p>\n<p>The most valuable place in any technological transition isn't at the old layer or the new one — it's at the boundary between them. Understanding how AI tools work, where they fail, how they compose with existing systems, what they can't reason about — that's where judgment lives. And judgment doesn't get automated easily.</p>\n<p><strong>Acknowledge the cost of transition — in yourself and in others.</strong></p>\n<p>If you're in a position of privilege in this wave — senior, established, with runway — use it to help people who aren't. The expansion of the market is not evenly distributed. Mentorship, advocacy, honest writing about what's actually happening: these matter.</p>\n<hr>\n<h2>The Building Keeps Growing</h2>\n<p>I can't tell you when the brick phase ends. I can't tell you exactly what the new floor looks like, or what your role will be on it.</p>\n<p>What I can tell you is this: every previous wave that felt like the end of software development turned out to be the beginning of a larger one. The building didn't fall — it grew taller. And a taller building needs more engineers, not fewer.</p>\n<p>AI is not the end of programming.</p>\n<p>It's another floor in a building that has been under construction for decades.</p>\n<p>The question isn't whether you'll have a place in it.</p>\n<p>The question is which floor you'll choose to build.</p>"
    },
    "_id": "blog/en/ai-and-developers-another-brick-or-another-floor.md",
    "_raw": {
      "sourceFilePath": "blog/en/ai-and-developers-another-brick-or-another-floor.md",
      "sourceFileName": "ai-and-developers-another-brick-or-another-floor.md",
      "sourceFileDir": "blog/en",
      "contentType": "markdown",
      "flattenedPath": "blog/en/ai-and-developers-another-brick-or-another-floor"
    },
    "type": "Post",
    "locale": "en",
    "slug": "ai-and-developers-another-brick-or-another-floor",
    "url": "/blog/ai-and-developers-another-brick-or-another-floor"
  },
  {
    "title": "The first draft of Programação Orientada a Gambiarra",
    "description": "A short update on my first complete draft, and what this book is really about.",
    "date": "2026-02-19T03:00:00.000Z",
    "author": "Josenaldo Matos",
    "category": "personal",
    "image": "/images/blog/programacao-orientada-a-gambiarra-first-draft.png",
    "body": {
      "raw": "\nI just finished the first complete draft of [**Programação Orientada a Gambiarra** - https://livropog.com.br/](https://livropog.com.br/).\n\nIf you’re not Brazilian, the word _gambiarra_ might sound mysterious. It’s the kind of improvised fix you do when reality doesn’t match the plan: a workaround, a hack, a duct-tape solution. It can be brilliant, dangerous, embarrassing, or all of the above.\n\nThis book is not a celebration of messy code. It’s an attempt to describe something we all do (especially under deadlines): we bend constraints. The core idea is simple: a “gambiarra” becomes less harmful when it is _oriented_—when you treat it as a deliberate design decision with context, boundaries, and a cleanup strategy.\n\nIn the draft, I try to answer questions like:\n\n- When is a shortcut acceptable, and when is it just technical debt disguised as courage?\n- How do you document a workaround so the next person doesn’t turn it into a permanent architecture?\n- What makes a quick fix safe enough to ship, and what makes it a production incident waiting to happen?\n\nYou’ll find stories and patterns: how to create “escape hatches” without turning your system into a maze, how to choose the smallest change that reduces risk, and how to communicate trade-offs without guilt-tripping yourself or your team.\n\nThe first draft is rough, but it’s complete. Now comes the hard part: cutting fluff, tightening examples, and making sure every chapter helps you build software that survives reality—without pretending reality is tidy.\n",
      "html": "<p>I just finished the first complete draft of <a href=\"https://livropog.com.br/\"><strong>Programação Orientada a Gambiarra</strong> - https://livropog.com.br/</a>.</p>\n<p>If you’re not Brazilian, the word <em>gambiarra</em> might sound mysterious. It’s the kind of improvised fix you do when reality doesn’t match the plan: a workaround, a hack, a duct-tape solution. It can be brilliant, dangerous, embarrassing, or all of the above.</p>\n<p>This book is not a celebration of messy code. It’s an attempt to describe something we all do (especially under deadlines): we bend constraints. The core idea is simple: a “gambiarra” becomes less harmful when it is <em>oriented</em>—when you treat it as a deliberate design decision with context, boundaries, and a cleanup strategy.</p>\n<p>In the draft, I try to answer questions like:</p>\n<ul>\n<li>When is a shortcut acceptable, and when is it just technical debt disguised as courage?</li>\n<li>How do you document a workaround so the next person doesn’t turn it into a permanent architecture?</li>\n<li>What makes a quick fix safe enough to ship, and what makes it a production incident waiting to happen?</li>\n</ul>\n<p>You’ll find stories and patterns: how to create “escape hatches” without turning your system into a maze, how to choose the smallest change that reduces risk, and how to communicate trade-offs without guilt-tripping yourself or your team.</p>\n<p>The first draft is rough, but it’s complete. Now comes the hard part: cutting fluff, tightening examples, and making sure every chapter helps you build software that survives reality—without pretending reality is tidy.</p>"
    },
    "_id": "blog/en/first-draft-programacao-orientada-a-gambiarra.md",
    "_raw": {
      "sourceFilePath": "blog/en/first-draft-programacao-orientada-a-gambiarra.md",
      "sourceFileName": "first-draft-programacao-orientada-a-gambiarra.md",
      "sourceFileDir": "blog/en",
      "contentType": "markdown",
      "flattenedPath": "blog/en/first-draft-programacao-orientada-a-gambiarra"
    },
    "type": "Post",
    "locale": "en",
    "slug": "first-draft-programacao-orientada-a-gambiarra",
    "url": "/blog/first-draft-programacao-orientada-a-gambiarra"
  },
  {
    "title": "Interfaces aren't villains",
    "description": "A technical and architectural analysis on the value of defining explicit contracts even when there's only one concrete implementation.",
    "date": "2025-12-24T12:00:00.000Z",
    "author": "Josenaldo Matos",
    "category": "architecture",
    "image": "/images/blog/interfaces-arent-villains.png",
    "body": {
      "raw": "\nThere's a growing narrative in engineering teams: \"let's not create an interface now because that's overengineering.\"\n\nIt stems from a real frustration. Many projects accumulate unnecessary layers just to \"look like architecture.\" And when change never comes, all that's left is a sense of waste.\n\nThe criticism is valid. The diagnosis, not always.\n\nThe right target isn't the interface itself. It's speculative abstraction: the kind that doesn't protect a real boundary and doesn't reduce impact.\n\nInterfaces don't exist to \"predict the future.\"\nInterfaces exist to **limit the impact of the present**.\n\nPractical rule: if a contract reduces surface area and protects a boundary, it's worth it. If it just changes syntax without protecting anyone, it becomes decoration.\n\n---\n\n## Where the criticism hits — and where it misses\n\nIt hits when it calls out:\n\n- abstractions created without need\n- layers that protect nothing\n- \"cosmetic complexity\" to look professional\n\nBut it misses when it concludes that:\n\n- \"if there's only one implementation, don't use an interface\"\n- \"interfaces only exist to swap vendors\"\n- \"this violates YAGNI\"\n\nIn reality, this conclusion becomes dangerous because it conflates different concepts:\n\n| Thing        | What it is                     | Benefit                 | Cost   | When to use                    |\n| ------------ | ------------------------------ | ----------------------- | ------ | ------------------------------ |\n| Interface    | Boundary contract              | Reduces external impact | Low    | Dependencies and exposure      |\n| Abstraction  | Way to organize solution space | Medium                  | Medium | When concrete variation exists |\n| Extra layers | Speculative structure          | Low/Uncertain           | High   | Only with proven need          |\n\n**Creating an interface ≠ creating layers.**\n\nThis contrast shows that an interface, by itself, doesn't add significant architectural weight.\n\nWhat makes maintenance expensive is building structures that don't delineate real boundaries. Interfaces act as contracts that stabilize interactions; extra layers are born to accommodate scenarios that may never exist.\n\nConflating these elements leads to reactive decisions: useful interfaces are eliminated to avoid excesses that should be prevented with design discipline.\n\n---\n\n## Without an interface: the hidden problem\n\n```java\nclass CheckoutService {\n    private final ThirdPartySDK sdk;\n\n    CheckoutService(ThirdPartySDK sdk) {\n        this.sdk = sdk;\n    }\n\n    public PaymentResponse pay(PaymentRequest req) {\n        return sdk.execute(req); // direct dependency\n    }\n}\n```\n\nWhat's happening here?\n\n- The part of the system that should be stable depends directly on an external API outside our control.\n- No barrier prevents SDK decisions from leaking into the system.\n- Swapping vendors, updating versions, or handling a breaking change becomes surgery.\n\nEverything works — until the day it doesn't.\n\nThe absence of an explicit contract leads to erosive coupling. Every place that touches `ThirdPartySDK` replicates assumptions about parameters, exception handling, and response semantics. Architectural knowledge spreads across code fragments, the team loses visibility of critical dependencies, and the cost of change explodes. The system gains accidental complexity without gaining any protective mechanism.\n\nThe most insidious part is that this seems cheap at first: no extra file, no \"contract.\" The cost appears later, when the dependency changes and you discover how many places knew too much.\n\n---\n\n## With an interface: the explicit contract\n\n```java\npublic interface PaymentGateway {\n    PaymentResponse pay(PaymentRequest req);\n}\n\npublic class ThirdPartyPaymentGateway implements PaymentGateway {\n    private final ThirdPartySDK sdk;\n\n    public ThirdPartyPaymentGateway(ThirdPartySDK sdk) {\n        this.sdk = sdk;\n    }\n\n    @Override\n    public PaymentResponse pay(PaymentRequest req) {\n        return sdk.execute(req);\n    }\n}\n\npublic class CheckoutService {\n    private final PaymentGateway gateway;\n\n    public CheckoutService(PaymentGateway gateway) {\n        this.gateway = gateway;\n    }\n\n    public PaymentResponse pay(PaymentRequest req) {\n        return gateway.pay(req);\n    }\n}\n```\n\nImmediate benefits:\n\n- the external dependency is isolated\n- the public surface is smaller and clearer\n- the system core doesn't know the vendor\n- swapping the SDK is local work, not systemic\n- testing becomes simpler (test doubles without SDK)\n\n**None of this requires a second implementation.**\nThe interface adds value even when it's unique.\n\nInterfaces bring cognitive clarity: they establish a ubiquitous language for essential behavior and create a controlled extension point.\n\nThe concrete implementation remains unique, but the reverse coupling (from system core to vendor) disappears. Even if substitution never happens, the team benefits today from simpler tests, clearer SRP, and implicit contract documentation.\n\n---\n\n## Where this lives in architecture\n\n- **Clean Architecture**: the interface is a boundary; the adapter is a detail.\n- **Hexagonal**: the interface is a port; the implementation is an adapter.\n- **Spring**: the contract enables IoC/DI without tight coupling.\n- **DDD**: the contract is part of the bounded context, not the implementation.\n\nThe interface doesn't predict change.\nIt makes change possible.\n\nBy placing the interface inside the policy circle (or domain), we ensure the external side takes responsibility for variation. This aligns architectural design with principles like Dependency Inversion and reinforces the autonomy of core modules. Unit tests come to depend on simple test doubles; integrations take on an explicit role as adapters, with their own lifecycle and observability.\n\nIf you need a simple heuristic: the interface usually belongs to whoever wants stability (the consumer). The vendor becomes a detail that implements the contract.\n\n---\n\n## The change nobody predicted: software rot\n\nThere is a class of change that rarely appears in the \"should I use an interface?\" debate, even though it's arguably the most certain one: **the software itself will decay.**\n\nNot because your team makes bad decisions. Not because requirements are unclear. Simply because the world around the code keeps moving.\n\nConsider what happens over five years of a production system:\n\n- The JVM or runtime gets updated — and a dependency breaks silently.\n- The cloud provider deprecates an API version your SDK depended on.\n- A framework upgrade changes injection semantics or lifecycle contracts.\n- The database driver introduces a new behavior with the same method signature.\n- A security patch in an OS library changes how a connection pool behaves.\n\nAt no point did anyone decide to \"swap Postgres for Oracle.\" Nobody planned to change the payment vendor. Nobody wanted to touch the authentication library. But the library touched them — because that's what software does. It rots.\n\n**Software rot** (sometimes called *bit rot* or *entropy*) is the gradual degradation of a system's operational environment while the code itself stays still. The surrounding world evolves: dependencies age, platforms shift, security requirements tighten. Code that worked in 2020 may fail in 2025 without a single intentional change.\n\nThis is precisely where abstractions and separation of concerns prove their worth beyond the \"swap vendor\" scenario.\n\nWhen external dependencies sit behind a contract, adapting to rot becomes local work:\n\n- the SDK changed its exception model → you fix one adapter\n- the database driver deprecated a method → you update one implementation\n- the cloud API returned a new field → you adjust the mapping in one place\n\nWithout the interface, this same event propagates. Every place that directly touched the dependency now needs to change, be reviewed, and be retested. The scope of a library patch is no longer the library — it's the entire codebase.\n\n**The interface doesn't protect you from change. It controls where change is allowed to land.**\n\nAnd since software rot is not a risk you can avoid — only a timeline you can't predict — designing for it is not overengineering. It's maintenance discipline.\n\n---\n\n## When an interface isn't worth it\n\n- purely internal services, without exposure\n- utility objects without external dependencies\n- stable functions within a single closed module\n- when the interface doesn't reduce surface area, just changes syntax\n\nIf the interface doesn't protect anyone, it serves no purpose.\n\nCreating an empty contract just shifts responsibilities without offering real cushioning. In these scenarios, the additional cognitive cost doesn't pay off: the team needs to maintain redundant classes, search extra references, and deal with less direct diagnostics. Interfaces are tools, not ornaments. Using them outside relevant boundaries violates the very purpose of impact reduction.\n\n---\n\n## When it's (very much) worth it\n\n- boundaries with databases and messaging systems\n- integrations with external services\n- inter-module or inter-domain communications\n- architectural risk points\n- where the cost of change is high or systemic\n\nIf the interface protects the domain, it has already paid for itself.\n\nThese points share a trait: they concentrate uncertainty and risk. An explicit contract allows introducing observability metrics in the adapter, applying resilience patterns (circuit breaker, retry, fallback), and testing the domain with test doubles that simulate extreme behaviors. Even a single implementation gains elasticity: alternative versions, additional instrumentation, or migration strategies can temporarily coexist under the same contract, without exponentially increasing entropy.\n\n---\n\n## Decision checklist (use before creating)\n\n| Question                                                  | If \"yes\", create interface |\n| --------------------------------------------------------- | -------------------------- |\n| Does this component touch something I don't control?      | Yes                        |\n| Might I need to update vendor, version, or stack?         | Yes                        |\n| If this dependency breaks, does the entire system suffer? | Yes                        |\n| Does this API expose too many details?                    | Yes                        |\n| Is there risk of impact beyond the current module?        | Yes                        |\n\nIf everything is \"no\", don't create it.\nIf one is \"yes\", your interface already has a reason.\n\nThis checklist acts as a conscious design exercise. It forces the team to reflect on responsibilities, boundaries, and impact before introducing or removing contracts. More importantly: it eliminates superficial discussions in code reviews, where criticism falls on the mere existence of the interface. The debate shifts to focus on concrete risk and necessary protection.\n\n---\n\n## Executive summary\n\nInterfaces aren't about the future.\nThey're about the cost of change **today**.\n\nChange doesn't only come from architectural decisions — swapping vendors, scaling teams, adding features. It also comes from entropy: runtime upgrades, deprecated APIs, security patches, framework evolution. Software rots not because teams fail, but because the world keeps moving around static code.\n\nThe interface is the firewall between your domain logic and everything that changes without asking permission.\n\nThat boundary pays for itself long before the second implementation ever appears.\n\n- Don't create interfaces to inflate architecture.\n- Don't create abstractions to win arguments in code reviews.\n- Create contracts to protect boundaries and reduce impact.\n\nYAGNI isn't \"don't do it.\"\nYAGNI is **\"don't do what protects nothing.\"**\n",
      "html": "<p>There's a growing narrative in engineering teams: \"let's not create an interface now because that's overengineering.\"</p>\n<p>It stems from a real frustration. Many projects accumulate unnecessary layers just to \"look like architecture.\" And when change never comes, all that's left is a sense of waste.</p>\n<p>The criticism is valid. The diagnosis, not always.</p>\n<p>The right target isn't the interface itself. It's speculative abstraction: the kind that doesn't protect a real boundary and doesn't reduce impact.</p>\n<p>Interfaces don't exist to \"predict the future.\"\nInterfaces exist to <strong>limit the impact of the present</strong>.</p>\n<p>Practical rule: if a contract reduces surface area and protects a boundary, it's worth it. If it just changes syntax without protecting anyone, it becomes decoration.</p>\n<hr>\n<h2>Where the criticism hits — and where it misses</h2>\n<p>It hits when it calls out:</p>\n<ul>\n<li>abstractions created without need</li>\n<li>layers that protect nothing</li>\n<li>\"cosmetic complexity\" to look professional</li>\n</ul>\n<p>But it misses when it concludes that:</p>\n<ul>\n<li>\"if there's only one implementation, don't use an interface\"</li>\n<li>\"interfaces only exist to swap vendors\"</li>\n<li>\"this violates YAGNI\"</li>\n</ul>\n<p>In reality, this conclusion becomes dangerous because it conflates different concepts:</p>\n<p>| Thing        | What it is                     | Benefit                 | Cost   | When to use                    |\n| ------------ | ------------------------------ | ----------------------- | ------ | ------------------------------ |\n| Interface    | Boundary contract              | Reduces external impact | Low    | Dependencies and exposure      |\n| Abstraction  | Way to organize solution space | Medium                  | Medium | When concrete variation exists |\n| Extra layers | Speculative structure          | Low/Uncertain           | High   | Only with proven need          |</p>\n<p><strong>Creating an interface ≠ creating layers.</strong></p>\n<p>This contrast shows that an interface, by itself, doesn't add significant architectural weight.</p>\n<p>What makes maintenance expensive is building structures that don't delineate real boundaries. Interfaces act as contracts that stabilize interactions; extra layers are born to accommodate scenarios that may never exist.</p>\n<p>Conflating these elements leads to reactive decisions: useful interfaces are eliminated to avoid excesses that should be prevented with design discipline.</p>\n<hr>\n<h2>Without an interface: the hidden problem</h2>\n<pre><code class=\"language-java\">class CheckoutService {\n    private final ThirdPartySDK sdk;\n\n    CheckoutService(ThirdPartySDK sdk) {\n        this.sdk = sdk;\n    }\n\n    public PaymentResponse pay(PaymentRequest req) {\n        return sdk.execute(req); // direct dependency\n    }\n}\n</code></pre>\n<p>What's happening here?</p>\n<ul>\n<li>The part of the system that should be stable depends directly on an external API outside our control.</li>\n<li>No barrier prevents SDK decisions from leaking into the system.</li>\n<li>Swapping vendors, updating versions, or handling a breaking change becomes surgery.</li>\n</ul>\n<p>Everything works — until the day it doesn't.</p>\n<p>The absence of an explicit contract leads to erosive coupling. Every place that touches <code>ThirdPartySDK</code> replicates assumptions about parameters, exception handling, and response semantics. Architectural knowledge spreads across code fragments, the team loses visibility of critical dependencies, and the cost of change explodes. The system gains accidental complexity without gaining any protective mechanism.</p>\n<p>The most insidious part is that this seems cheap at first: no extra file, no \"contract.\" The cost appears later, when the dependency changes and you discover how many places knew too much.</p>\n<hr>\n<h2>With an interface: the explicit contract</h2>\n<pre><code class=\"language-java\">public interface PaymentGateway {\n    PaymentResponse pay(PaymentRequest req);\n}\n\npublic class ThirdPartyPaymentGateway implements PaymentGateway {\n    private final ThirdPartySDK sdk;\n\n    public ThirdPartyPaymentGateway(ThirdPartySDK sdk) {\n        this.sdk = sdk;\n    }\n\n    @Override\n    public PaymentResponse pay(PaymentRequest req) {\n        return sdk.execute(req);\n    }\n}\n\npublic class CheckoutService {\n    private final PaymentGateway gateway;\n\n    public CheckoutService(PaymentGateway gateway) {\n        this.gateway = gateway;\n    }\n\n    public PaymentResponse pay(PaymentRequest req) {\n        return gateway.pay(req);\n    }\n}\n</code></pre>\n<p>Immediate benefits:</p>\n<ul>\n<li>the external dependency is isolated</li>\n<li>the public surface is smaller and clearer</li>\n<li>the system core doesn't know the vendor</li>\n<li>swapping the SDK is local work, not systemic</li>\n<li>testing becomes simpler (test doubles without SDK)</li>\n</ul>\n<p><strong>None of this requires a second implementation.</strong>\nThe interface adds value even when it's unique.</p>\n<p>Interfaces bring cognitive clarity: they establish a ubiquitous language for essential behavior and create a controlled extension point.</p>\n<p>The concrete implementation remains unique, but the reverse coupling (from system core to vendor) disappears. Even if substitution never happens, the team benefits today from simpler tests, clearer SRP, and implicit contract documentation.</p>\n<hr>\n<h2>Where this lives in architecture</h2>\n<ul>\n<li><strong>Clean Architecture</strong>: the interface is a boundary; the adapter is a detail.</li>\n<li><strong>Hexagonal</strong>: the interface is a port; the implementation is an adapter.</li>\n<li><strong>Spring</strong>: the contract enables IoC/DI without tight coupling.</li>\n<li><strong>DDD</strong>: the contract is part of the bounded context, not the implementation.</li>\n</ul>\n<p>The interface doesn't predict change.\nIt makes change possible.</p>\n<p>By placing the interface inside the policy circle (or domain), we ensure the external side takes responsibility for variation. This aligns architectural design with principles like Dependency Inversion and reinforces the autonomy of core modules. Unit tests come to depend on simple test doubles; integrations take on an explicit role as adapters, with their own lifecycle and observability.</p>\n<p>If you need a simple heuristic: the interface usually belongs to whoever wants stability (the consumer). The vendor becomes a detail that implements the contract.</p>\n<hr>\n<h2>The change nobody predicted: software rot</h2>\n<p>There is a class of change that rarely appears in the \"should I use an interface?\" debate, even though it's arguably the most certain one: <strong>the software itself will decay.</strong></p>\n<p>Not because your team makes bad decisions. Not because requirements are unclear. Simply because the world around the code keeps moving.</p>\n<p>Consider what happens over five years of a production system:</p>\n<ul>\n<li>The JVM or runtime gets updated — and a dependency breaks silently.</li>\n<li>The cloud provider deprecates an API version your SDK depended on.</li>\n<li>A framework upgrade changes injection semantics or lifecycle contracts.</li>\n<li>The database driver introduces a new behavior with the same method signature.</li>\n<li>A security patch in an OS library changes how a connection pool behaves.</li>\n</ul>\n<p>At no point did anyone decide to \"swap Postgres for Oracle.\" Nobody planned to change the payment vendor. Nobody wanted to touch the authentication library. But the library touched them — because that's what software does. It rots.</p>\n<p><strong>Software rot</strong> (sometimes called <em>bit rot</em> or <em>entropy</em>) is the gradual degradation of a system's operational environment while the code itself stays still. The surrounding world evolves: dependencies age, platforms shift, security requirements tighten. Code that worked in 2020 may fail in 2025 without a single intentional change.</p>\n<p>This is precisely where abstractions and separation of concerns prove their worth beyond the \"swap vendor\" scenario.</p>\n<p>When external dependencies sit behind a contract, adapting to rot becomes local work:</p>\n<ul>\n<li>the SDK changed its exception model → you fix one adapter</li>\n<li>the database driver deprecated a method → you update one implementation</li>\n<li>the cloud API returned a new field → you adjust the mapping in one place</li>\n</ul>\n<p>Without the interface, this same event propagates. Every place that directly touched the dependency now needs to change, be reviewed, and be retested. The scope of a library patch is no longer the library — it's the entire codebase.</p>\n<p><strong>The interface doesn't protect you from change. It controls where change is allowed to land.</strong></p>\n<p>And since software rot is not a risk you can avoid — only a timeline you can't predict — designing for it is not overengineering. It's maintenance discipline.</p>\n<hr>\n<h2>When an interface isn't worth it</h2>\n<ul>\n<li>purely internal services, without exposure</li>\n<li>utility objects without external dependencies</li>\n<li>stable functions within a single closed module</li>\n<li>when the interface doesn't reduce surface area, just changes syntax</li>\n</ul>\n<p>If the interface doesn't protect anyone, it serves no purpose.</p>\n<p>Creating an empty contract just shifts responsibilities without offering real cushioning. In these scenarios, the additional cognitive cost doesn't pay off: the team needs to maintain redundant classes, search extra references, and deal with less direct diagnostics. Interfaces are tools, not ornaments. Using them outside relevant boundaries violates the very purpose of impact reduction.</p>\n<hr>\n<h2>When it's (very much) worth it</h2>\n<ul>\n<li>boundaries with databases and messaging systems</li>\n<li>integrations with external services</li>\n<li>inter-module or inter-domain communications</li>\n<li>architectural risk points</li>\n<li>where the cost of change is high or systemic</li>\n</ul>\n<p>If the interface protects the domain, it has already paid for itself.</p>\n<p>These points share a trait: they concentrate uncertainty and risk. An explicit contract allows introducing observability metrics in the adapter, applying resilience patterns (circuit breaker, retry, fallback), and testing the domain with test doubles that simulate extreme behaviors. Even a single implementation gains elasticity: alternative versions, additional instrumentation, or migration strategies can temporarily coexist under the same contract, without exponentially increasing entropy.</p>\n<hr>\n<h2>Decision checklist (use before creating)</h2>\n<p>| Question                                                  | If \"yes\", create interface |\n| --------------------------------------------------------- | -------------------------- |\n| Does this component touch something I don't control?      | Yes                        |\n| Might I need to update vendor, version, or stack?         | Yes                        |\n| If this dependency breaks, does the entire system suffer? | Yes                        |\n| Does this API expose too many details?                    | Yes                        |\n| Is there risk of impact beyond the current module?        | Yes                        |</p>\n<p>If everything is \"no\", don't create it.\nIf one is \"yes\", your interface already has a reason.</p>\n<p>This checklist acts as a conscious design exercise. It forces the team to reflect on responsibilities, boundaries, and impact before introducing or removing contracts. More importantly: it eliminates superficial discussions in code reviews, where criticism falls on the mere existence of the interface. The debate shifts to focus on concrete risk and necessary protection.</p>\n<hr>\n<h2>Executive summary</h2>\n<p>Interfaces aren't about the future.\nThey're about the cost of change <strong>today</strong>.</p>\n<p>Change doesn't only come from architectural decisions — swapping vendors, scaling teams, adding features. It also comes from entropy: runtime upgrades, deprecated APIs, security patches, framework evolution. Software rots not because teams fail, but because the world keeps moving around static code.</p>\n<p>The interface is the firewall between your domain logic and everything that changes without asking permission.</p>\n<p>That boundary pays for itself long before the second implementation ever appears.</p>\n<ul>\n<li>Don't create interfaces to inflate architecture.</li>\n<li>Don't create abstractions to win arguments in code reviews.</li>\n<li>Create contracts to protect boundaries and reduce impact.</li>\n</ul>\n<p>YAGNI isn't \"don't do it.\"\nYAGNI is <strong>\"don't do what protects nothing.\"</strong></p>"
    },
    "_id": "blog/en/interfaces-arent-villains.md",
    "_raw": {
      "sourceFilePath": "blog/en/interfaces-arent-villains.md",
      "sourceFileName": "interfaces-arent-villains.md",
      "sourceFileDir": "blog/en",
      "contentType": "markdown",
      "flattenedPath": "blog/en/interfaces-arent-villains"
    },
    "type": "Post",
    "locale": "en",
    "slug": "interfaces-arent-villains",
    "url": "/blog/interfaces-arent-villains"
  },
  {
    "title": "Is learning coding really hard?",
    "description": "Spoiler: Learn how to code isn't hard. Its just a lot of work. And we usually confuse these two concepts.",
    "date": "2023-06-15T01:00:00.000Z",
    "author": "Josenaldo Matos",
    "category": "learning",
    "image": "/images/blog/learn-coding-is-not-hard.png",
    "body": {
      "raw": "\nIs it hard to learn coding well enough to become a professional developer?\n\nSpoiler: No. It's not hard. It's labor-intensive. And we often confuse these two concepts.\n\n## Your life isn't easy\n\nSo, you know nothing about coding. And your life seems like a complete mess! You might feel entirely overwhelmed.\n\nPerhaps you're dealing with numerous problems. Maybe you're working to pay the bills, or caring for your children or parents. Possibly, you're tending to your health or grappling with a severe health condition. You might be hungry, tired, sick, depressed, anxious, afraid, sad, angry, desperate, hopeless. The list seems endless.\n\nYes, it feels as though you're at the rock bottom of a deep pit.\n\nHere, you have two choices: stay or climb.\n\nI won't sugarcoat the truth: your situation seems severe and I don't possess a magic solution to dissolve your problems. My name is Josenaldo, not Jesus.\n\nWhat I can offer you, however, is a suggestion: learn to code.\n\n## Why Learn to Code?\n\nBecause you're financially challenged and it's a potential escape! It's a way to change your life, especially if you live in a country like Brazil, where the minimum wage may not cover your bills.\n\nYou don't need to love it. I'm not telling you how to become happy or how to find the meaning of life. I'm suggesting a survival strategy.\n\nYour task is to climb. After you've ascended, you can decide what to do with your life. But first, you must climb.\n\nIs it easy? No. But staying stagnant at the bottom of the pit is much harder.\n\nBecoming a developer is ONE pathway to change your life. And it's a FEASIBLE pathway.\n\n## What Do You Need to Start?\n\nThere are some essentials you'll need to begin:\n\n- A computer or a smartphone (if you're reading this, you likely have access to one of these)\n- Internet access\n- Time\n- Resilience\n\nSecuring a computer and internet access are perhaps the \"easiest\" items to acquire. If you don't have them, public libraries, a friend's house, or a café could provide access.\n\nHowever, when we start talking about time and resilience, things get a bit more complex.\n\n### Time and Resilience\n\nAcquiring a skill requires time - a lot of time. We're not talking about days or weeks here. We're talking about months, even years. This isn't a sprint; it's a marathon.\n\nI understand that this is a significant hurdle for many. But it's not impossible. All it requires is patience and persistence.\n\nBecoming a developer is akin to climbing a 200-story building using stairs.\n\nClimbing stairs seems easy enough, one step after another, right?\n\nBut climbing 200 stories requires enormous energy! And the degree of difficulty isn't the same for everyone.\n\nFor some, climbing just 2 floors is already a challenge, because they lack energy, or because they're hungry. For others, it's difficult because they don't have time, or because of some disability.\n\nBut, the question remains: despite these challenges, is it possible to climb 200 floors? Yes, it is.\n\n## How to Begin the Climb\n\nClimbing this building is labor-intensive, but it's accessible - far more than many others.\n\nTo gain entry into fields like medicine or law, for instance, the cost is so prohibitive that it's unattainable for most. You might not even make it past the door!\n\nYet, to enter the world of software development, you can essentially walk in for \"free\". The door is wide open, and all the steps are within your reach!\n\nHow so?\n\nAll the knowledge you need is available on the internet. EVERYTHING. And it's available at no cost. All you need to do is access it.\n\nThere are quality paid courses available. But if you have the funds for those, we likely don't need to continue this discussion.\n\nYou can access websites like Mozilla Developer Network, W3Schools, FreeCodeCamp, Codecademy, Udemy, YouTube, etc. Or you can learn using ChatGPT, a chatbot that can answer your questions about virtually anything.\n\nJust start! Choose one of these resources and begin! Start small, take baby steps, but start nonetheless!\n\n## How to Learn\n\nWhat is an self-taught person? It's a person who learns by himself, without a teacher, right?\n\nWrong.\n\nA self-taught person is a person who learns by himself, but with a lot of teachers.\n\nWhen you read a book, the book author become your teacher. When you watch a video, the video author become your teacher. When you read a blog post, the blog post author become your teacher.\n\nYou can learn from anyone, anywhere, anytime. You just have to be open to learn.\n\nTo learn how to code, you can use a lot of resources. You can read books, watch videos, read blog posts, listen to podcasts, etc. And, you NEED PRACTICE.\n\nThat the point where a lot of people get stuck or even give up. They dont practice. They just read, watch, listen, but they don't practice.\n\nCoding is a skill. And, like any other skill, the learning is based on two things:\n\n- Aquire the information (theory)\n- Train the skill (practice)\n\nTo learn the basics of how to programming, you will need about 200 hours. If you spend 4 hours a week, you'll need 50 weeks. It's almost a year!\n\n\"Then, if I study 4 hours a day, I'll be a developer in 50 days?\"\n\nNo. Your brain doesn't work in that way.\n\nIf you go to the gym, after years without lift any weight, and lift 200kg, you won't be a bodybuilder. You'll be dead.\n\nIf you try run a marathon without any training, you won't be a marathon runner. You'll hurt yourself.\n\nLearny how to code isn't different. You need to study and practice. And your body (specially your brain) needs time to adapt. You need to start small and go bigger.\n\nTherefore, your brain cannot absorve all the information at one time. You have limits on what you can learn in a day. Thats the reason why you need to study and practice every day. And why you need to REST.\n\n## How to practice\n\nTo learn how to code, you need to practice. But how?\n\nYou can practice by yourself, doing exercises, building projects, etc. But you can also practice with other people.\n\nYou can join a study group, a bootcamp, a course, a workshop, a hackathon, etc.\n\nYou can also practice by teaching. You can teach your friends, your family, your coworkers, etc.\n\n## Consistence\n\nThe key to learn how to code is consistence. You need to study and practice every day (or, at least, sometimes in a week). Even if you don't want to. Even if you are tired. Even if you are sad. Even if you are happy.\n\nLearn - Pratice - Rest. Repeat.\n\nWait... REST?\n\nYes. Rest is important. You need to rest. You need to SLEEP. You need to eat. You need to drink water. You need to exercise. You need to take care of yourself.\n\nRemember, this is a marathon, not a sprint!\n\nWithou the proper sleeping, for exemple, you can't learn. Your brain needs to rest to process the information you learned during the day. Sleep less can turn you dumber! Literaly!\n\n## Overall\n\nLearn how to code isn't hard. It's just hard-working. But it's possible. And it's worth it.\n\nIf you are in a bad situation, looking for a way out, look at this path. You can learn to code.\n\nYou don't need to like it. You just have to do it.\n\nScrewed, you're already. From the bottom of the pit, there's only one way up.\n",
      "html": "<p>Is it hard to learn coding well enough to become a professional developer?</p>\n<p>Spoiler: No. It's not hard. It's labor-intensive. And we often confuse these two concepts.</p>\n<h2>Your life isn't easy</h2>\n<p>So, you know nothing about coding. And your life seems like a complete mess! You might feel entirely overwhelmed.</p>\n<p>Perhaps you're dealing with numerous problems. Maybe you're working to pay the bills, or caring for your children or parents. Possibly, you're tending to your health or grappling with a severe health condition. You might be hungry, tired, sick, depressed, anxious, afraid, sad, angry, desperate, hopeless. The list seems endless.</p>\n<p>Yes, it feels as though you're at the rock bottom of a deep pit.</p>\n<p>Here, you have two choices: stay or climb.</p>\n<p>I won't sugarcoat the truth: your situation seems severe and I don't possess a magic solution to dissolve your problems. My name is Josenaldo, not Jesus.</p>\n<p>What I can offer you, however, is a suggestion: learn to code.</p>\n<h2>Why Learn to Code?</h2>\n<p>Because you're financially challenged and it's a potential escape! It's a way to change your life, especially if you live in a country like Brazil, where the minimum wage may not cover your bills.</p>\n<p>You don't need to love it. I'm not telling you how to become happy or how to find the meaning of life. I'm suggesting a survival strategy.</p>\n<p>Your task is to climb. After you've ascended, you can decide what to do with your life. But first, you must climb.</p>\n<p>Is it easy? No. But staying stagnant at the bottom of the pit is much harder.</p>\n<p>Becoming a developer is ONE pathway to change your life. And it's a FEASIBLE pathway.</p>\n<h2>What Do You Need to Start?</h2>\n<p>There are some essentials you'll need to begin:</p>\n<ul>\n<li>A computer or a smartphone (if you're reading this, you likely have access to one of these)</li>\n<li>Internet access</li>\n<li>Time</li>\n<li>Resilience</li>\n</ul>\n<p>Securing a computer and internet access are perhaps the \"easiest\" items to acquire. If you don't have them, public libraries, a friend's house, or a café could provide access.</p>\n<p>However, when we start talking about time and resilience, things get a bit more complex.</p>\n<h3>Time and Resilience</h3>\n<p>Acquiring a skill requires time - a lot of time. We're not talking about days or weeks here. We're talking about months, even years. This isn't a sprint; it's a marathon.</p>\n<p>I understand that this is a significant hurdle for many. But it's not impossible. All it requires is patience and persistence.</p>\n<p>Becoming a developer is akin to climbing a 200-story building using stairs.</p>\n<p>Climbing stairs seems easy enough, one step after another, right?</p>\n<p>But climbing 200 stories requires enormous energy! And the degree of difficulty isn't the same for everyone.</p>\n<p>For some, climbing just 2 floors is already a challenge, because they lack energy, or because they're hungry. For others, it's difficult because they don't have time, or because of some disability.</p>\n<p>But, the question remains: despite these challenges, is it possible to climb 200 floors? Yes, it is.</p>\n<h2>How to Begin the Climb</h2>\n<p>Climbing this building is labor-intensive, but it's accessible - far more than many others.</p>\n<p>To gain entry into fields like medicine or law, for instance, the cost is so prohibitive that it's unattainable for most. You might not even make it past the door!</p>\n<p>Yet, to enter the world of software development, you can essentially walk in for \"free\". The door is wide open, and all the steps are within your reach!</p>\n<p>How so?</p>\n<p>All the knowledge you need is available on the internet. EVERYTHING. And it's available at no cost. All you need to do is access it.</p>\n<p>There are quality paid courses available. But if you have the funds for those, we likely don't need to continue this discussion.</p>\n<p>You can access websites like Mozilla Developer Network, W3Schools, FreeCodeCamp, Codecademy, Udemy, YouTube, etc. Or you can learn using ChatGPT, a chatbot that can answer your questions about virtually anything.</p>\n<p>Just start! Choose one of these resources and begin! Start small, take baby steps, but start nonetheless!</p>\n<h2>How to Learn</h2>\n<p>What is an self-taught person? It's a person who learns by himself, without a teacher, right?</p>\n<p>Wrong.</p>\n<p>A self-taught person is a person who learns by himself, but with a lot of teachers.</p>\n<p>When you read a book, the book author become your teacher. When you watch a video, the video author become your teacher. When you read a blog post, the blog post author become your teacher.</p>\n<p>You can learn from anyone, anywhere, anytime. You just have to be open to learn.</p>\n<p>To learn how to code, you can use a lot of resources. You can read books, watch videos, read blog posts, listen to podcasts, etc. And, you NEED PRACTICE.</p>\n<p>That the point where a lot of people get stuck or even give up. They dont practice. They just read, watch, listen, but they don't practice.</p>\n<p>Coding is a skill. And, like any other skill, the learning is based on two things:</p>\n<ul>\n<li>Aquire the information (theory)</li>\n<li>Train the skill (practice)</li>\n</ul>\n<p>To learn the basics of how to programming, you will need about 200 hours. If you spend 4 hours a week, you'll need 50 weeks. It's almost a year!</p>\n<p>\"Then, if I study 4 hours a day, I'll be a developer in 50 days?\"</p>\n<p>No. Your brain doesn't work in that way.</p>\n<p>If you go to the gym, after years without lift any weight, and lift 200kg, you won't be a bodybuilder. You'll be dead.</p>\n<p>If you try run a marathon without any training, you won't be a marathon runner. You'll hurt yourself.</p>\n<p>Learny how to code isn't different. You need to study and practice. And your body (specially your brain) needs time to adapt. You need to start small and go bigger.</p>\n<p>Therefore, your brain cannot absorve all the information at one time. You have limits on what you can learn in a day. Thats the reason why you need to study and practice every day. And why you need to REST.</p>\n<h2>How to practice</h2>\n<p>To learn how to code, you need to practice. But how?</p>\n<p>You can practice by yourself, doing exercises, building projects, etc. But you can also practice with other people.</p>\n<p>You can join a study group, a bootcamp, a course, a workshop, a hackathon, etc.</p>\n<p>You can also practice by teaching. You can teach your friends, your family, your coworkers, etc.</p>\n<h2>Consistence</h2>\n<p>The key to learn how to code is consistence. You need to study and practice every day (or, at least, sometimes in a week). Even if you don't want to. Even if you are tired. Even if you are sad. Even if you are happy.</p>\n<p>Learn - Pratice - Rest. Repeat.</p>\n<p>Wait... REST?</p>\n<p>Yes. Rest is important. You need to rest. You need to SLEEP. You need to eat. You need to drink water. You need to exercise. You need to take care of yourself.</p>\n<p>Remember, this is a marathon, not a sprint!</p>\n<p>Withou the proper sleeping, for exemple, you can't learn. Your brain needs to rest to process the information you learned during the day. Sleep less can turn you dumber! Literaly!</p>\n<h2>Overall</h2>\n<p>Learn how to code isn't hard. It's just hard-working. But it's possible. And it's worth it.</p>\n<p>If you are in a bad situation, looking for a way out, look at this path. You can learn to code.</p>\n<p>You don't need to like it. You just have to do it.</p>\n<p>Screwed, you're already. From the bottom of the pit, there's only one way up.</p>"
    },
    "_id": "blog/en/learn-coding-is-not-hard.md",
    "_raw": {
      "sourceFilePath": "blog/en/learn-coding-is-not-hard.md",
      "sourceFileName": "learn-coding-is-not-hard.md",
      "sourceFileDir": "blog/en",
      "contentType": "markdown",
      "flattenedPath": "blog/en/learn-coding-is-not-hard"
    },
    "type": "Post",
    "locale": "en",
    "slug": "learn-coding-is-not-hard",
    "url": "/blog/learn-coding-is-not-hard"
  },
  {
    "title": "The return of the Jedi",
    "description": "This post marks the beginning of a new journey in my life: my fight for my return to the world of software development.",
    "date": "2023-04-15T01:00:00.000Z",
    "author": "Josenaldo Matos",
    "category": "personal",
    "image": "/images/blog/return-of-the-jedi.png",
    "body": {
      "raw": "\nHello, everyone! My name is Josenaldo Matos, and I'm incredibly excited to be launching my new blog, Nephro Nerd Chronicles. This first post is about how I'm embarking on a journey to return to work after a long and challenging period in my life.\n\nI've been working in software development since 1999, and I'm passionate about creating web applications, especially using Java and JavaScript. However, my life took an unexpected turn in 2008 when I lost my kidney function and had to start hemodialysis. Through the years, I've had to overcome many obstacles, including a kidney transplant, multiple accidents, and the loss of a loved one.\n\nDespite these challenges, I've always remained passionate about software development and have continued learning new technologies. My motivation for returning to work is twofold: I love the satisfaction of solving problems and creating useful tools, and I need to support my family and achieve our dreams.\n\nCurrently, I face some difficulties due to my health and hemodialysis schedule, but I'm determined not to let these obstacles stand in my way. My goal is to find a job that allows me to be productive, create value, and earn a good income without jeopardizing my health.\n\nLooking ahead, I envision a future where I can provide a better life for my family and myself by creating a comfortable and productive home environment. Through hard work and determination, I believe that I can overcome the challenges I face and achieve success in both my personal and professional life.\n\nThank you for joining me on this journey, and I look forward to sharing more about my experiences, interests, and the world of software development here on Nephro Nerd Chronicles. Stay tuned for more posts, and feel free to reach out if you have any questions or suggestions.\n\nLet the adventure begin!\n",
      "html": "<p>Hello, everyone! My name is Josenaldo Matos, and I'm incredibly excited to be launching my new blog, Nephro Nerd Chronicles. This first post is about how I'm embarking on a journey to return to work after a long and challenging period in my life.</p>\n<p>I've been working in software development since 1999, and I'm passionate about creating web applications, especially using Java and JavaScript. However, my life took an unexpected turn in 2008 when I lost my kidney function and had to start hemodialysis. Through the years, I've had to overcome many obstacles, including a kidney transplant, multiple accidents, and the loss of a loved one.</p>\n<p>Despite these challenges, I've always remained passionate about software development and have continued learning new technologies. My motivation for returning to work is twofold: I love the satisfaction of solving problems and creating useful tools, and I need to support my family and achieve our dreams.</p>\n<p>Currently, I face some difficulties due to my health and hemodialysis schedule, but I'm determined not to let these obstacles stand in my way. My goal is to find a job that allows me to be productive, create value, and earn a good income without jeopardizing my health.</p>\n<p>Looking ahead, I envision a future where I can provide a better life for my family and myself by creating a comfortable and productive home environment. Through hard work and determination, I believe that I can overcome the challenges I face and achieve success in both my personal and professional life.</p>\n<p>Thank you for joining me on this journey, and I look forward to sharing more about my experiences, interests, and the world of software development here on Nephro Nerd Chronicles. Stay tuned for more posts, and feel free to reach out if you have any questions or suggestions.</p>\n<p>Let the adventure begin!</p>"
    },
    "_id": "blog/en/return-of-the-jedi.md",
    "_raw": {
      "sourceFilePath": "blog/en/return-of-the-jedi.md",
      "sourceFileName": "return-of-the-jedi.md",
      "sourceFileDir": "blog/en",
      "contentType": "markdown",
      "flattenedPath": "blog/en/return-of-the-jedi"
    },
    "type": "Post",
    "locale": "en",
    "slug": "return-of-the-jedi",
    "url": "/blog/return-of-the-jedi"
  },
  {
    "title": "Why am I still invisible?",
    "description": "Why, despite being qualified, am I still invisible to the job market?",
    "date": "2024-08-01T01:00:00.000Z",
    "author": "Josenaldo Matos",
    "category": "job-market",
    "image": "/images/blog/why-am-i-still-invisible.png",
    "body": {
      "raw": "\nI saw [this LinkedIn post by Pablo Jorge Maciel](https://www.linkedin.com/posts/pjmaciel_um-desabafo-sobre-a-ti-e-o-tech-recruiter-activity-7224531473201037313-_KIJ), where he vents and questions why, despite being qualified, he's still invisible to the job market. I related strongly to what he said. So I decided to write this post to share my thoughts on the subject with you.\n\nThere are two ways to get a job: hunting and farming.\n\nI saw this definition on Twitter (_I'll never call it X_), in this thread by [@SergioRocks](https://x.com/SergioRocks/status/1811386383258272092), and I thought it was really good.\n\nHunting is when you actively go after work. It's when you send your resume, when you apply. It's when you network, when you go to events, when you introduce yourself. It's when you cold call, when you message on LinkedIn. It's when you interview, when you take tests. It's when you chase it down.\n\nFarming is when you \"cultivate\" good relationships and reputation until the fruits start falling at your feet and you start being called, referred, and invited. Sounds good, right?\n\nThe problem is that farming takes time and considerable effort. This means we have to rely much more on hunting in the short term than on farming. This emphasis on hunting can lead to forgetting farming practices, resulting in invisibility in the job market.\n\n## The problem with hunting\n\nHunting seems to offer more immediate results, but it takes a lot of work, consumes a lot of time, and the return rate is ridiculously low.\n\nThe practice of hunting can be compared to selling a product to individuals who don't know the seller: it's a numbers game and you're going to send your resume to MANY job openings. A LOT. In the hundreds. Maybe even thousands. And you'll do this knowing you'll get a pitiful return.\n\nAnd why is it like this? Because the hunting sales funnel is cruel.\n\n### The hunting sales funnel\n\nWe can say that hunting is a sales funnel. And, like any sales funnel, it has several stages and has a conversion rate. The issue here is that the hunting conversion rate, by nature, is very low.\n\nFor starters, a significant portion of job postings are ghost positions. Your resume won't even be read. There isn't even anyone on the other side. This position was created to meet a quota, to justify a budget, to create volume, or to give the impression that the company is growing. And you have no way of knowing which ones these are.\n\nOf those remaining, the ones that aren't ghosts, you probably won't get past the ATS automated screening stage. Yes, an AI will block you, because it can't read your resume, especially if it has columns, decorations, and embellishments. In this regard, the simpler the resume layout, the better. Avoid using columns, tables, graphs, images, icons, colors, different fonts, etc. It's also recommended to use file formats easily readable by artificial intelligence systems, such as .docx or PDF. Check out [my GitHub for a resume example I use](https://github.com/josenaldo). Feel free to download and use it.\n\nIn the next stage, you fight against time. If you apply for a position that received hundreds of applications, do you really think the recruitment team, with tight deadlines and few available people, will have time to read all the selected ones? If you arrived at the end of the line, the chance of even being seen is high.\n\nIn short, your chance of finding a real position, being selected by the ATS, being seen by the recruiter, and being called for an interview is very low. And if you reach this stage, you'll still have to go through the gauntlet to prove you're good enough and better than other candidates.\n\n### How to beat this funnel?\n\nPatience, determination, resilience, persistence, and NUMBERS.\n\nThere's lots of advice out there, but I'll summarize here:\n\n- Simplify your resume\n- Prefer ATS-compatible file formats, like PDF\n- Focus on positions well-aligned with your skills\n- Give preference to:\n    - more recent positions (the chance of old positions being ghosts is higher)\n    - positions with fewer applications (the chance of being seen is higher)\n- Apply to as many positions as possible. Keep sending resumes until your email provider starts suspecting you're trying to communicate with another planet.\n\nThere's not much way around it. If you need to find a job, you're going to have to sweat. However, while hunting is essential for an active and immediate search for opportunities, it shouldn't be the only strategy adopted.\n\n## And farming?\n\nSo... You don't want to spend the rest of your life hunting, right?\n\nWhile hunting may seem like the most straightforward strategy for entering the job market, it's important to recognize the value of farming. The latter can be seen as a long-term investment in your career. By cultivating relationships and building a solid reputation, you establish fertile ground that, over time, will bring opportunities to you more naturally and frequently. Thus, while hunting seeks immediate results, farming paves the way for future and sustainable opportunities. Therefore, let's plant!\n\nBut what exactly does 'planting' mean in the context of employability?\n\nThink of your career as a garden that needs to be cared for and cultivated to flourish. Just like a garden, your professional trajectory doesn't grow by chance; it requires attention, planning, and continuous care.\n\nImagine your work is like growing food: instead of depending on sporadic hunting trips, which can be uncertain and inconsistent, you develop a fertile field. This field, carefully maintained, begins to produce food regularly, providing a sustainable and reliable source of nutrition.\n\nHow do you apply this metaphor to your professional life?\n\nYou 'plant' by building and cultivating your reputation and your network.\n\n- **Cultivating your reputation**: This is about demonstrating your competence and reliability through consistent, high-quality work. Each successfully completed project, each positive feedback, and each innovative solution you offer are like seeds germinating in your professional field.\n- **Expanding your network**: Relating to other professionals is like watering and nourishing the soil. Participating in industry events, interacting on professional social media platforms, and collaborating on projects are ways to keep your 'field' healthy and productive. Each connection is a root that deepens into the soil of your career, bringing stability and opening new paths for opportunities.\n\nHere, patience is crucial. Just as a field doesn't produce an immediate harvest, networking and building a solid reputation take time and persistence. But once established, they provide valuable resources that can sustain your career for many years.\n\n### Cultivating your reputation in IT\n\nIn the IT field, reputation is intangible capital, but of invaluable worth. It functions as a currency in the vast technology job market, where professionals are continuously evaluated for their competencies and integrity. Being recognized as a good professional can open doors and facilitate recommendations; on the other hand, a negative reputation can create almost insurmountable barriers.\n\n#### Investing in building a solid reputation\n\n- **Consistent Quality**: The foundation of a good reputation starts with the consistent delivery of quality work. In IT, this means writing clean code, properly documenting your projects, and meeting deadlines. Every detail counts when your work is under scrutiny.\n- **Problem Solving**: Stand out as someone who not only identifies problems but who brings effective solutions. The ability to solve challenges creatively and efficiently is highly valued in the dynamic IT environment.\n- **Continuous Learning**: The technology field is always evolving, and staying updated with the latest technologies and practices is fundamental. Participating in courses, workshops, and seminars not only expands your knowledge but also demonstrates your commitment to self-development.\n- **Collaboration and Communication**: IT frequently involves teamwork. Being a team player who communicates clearly and contributes to collective success strengthens your reputation as someone reliable and collaborative.\n\n#### Building your sphere of influence\n\n- **Effective Networking**: Attend industry events, join professional groups, and interact on digital platforms specific to IT professionals. These spaces are ideal for demonstrating your expertise and learning from others.\n- **Contributions and Participation**: Contribute to open-source projects, publish articles about your areas of expertise, and participate in discussion forums. These activities put your name in circulation within the technology community and contribute to an image of an engaged and active professional.\n- **Feedback and Endorsements**: Ask for feedback regularly and accept constructive criticism. Endorsements from colleagues and superiors on platforms like LinkedIn can also validate your skills and strengthen your reputation.\n\nRemember that building a reputation takes time and requires continuous effort. You don't need to be a digital influencer or a technology genius, but it's crucial that your peers and industry leaders trust your ability to deliver results and contribute positively. By cultivating your reputation daily, you sow the seeds for a lasting and rewarding career in IT.\n\n### The empty field problem\n\nMany professionals at the beginning of their careers face a common dilemma: the lack of reputation and network. Without an established work history, they find themselves in what can be described as a \"catch-22\" — they don't have a reputation because they don't have work, and they can't get work because they don't have a reputation.\n\n#### Breaking the cycle\n\nTo overcome this challenge, it's crucial to understand that your reputation is intrinsically linked to your results. If traditional results aren't yet an option, you need to create opportunities for yourself.\n\n**If you chose the academic path**\n\nYou don't go to college to make friends, but to become a qualified professional. Therefore, make the most of your academic experience.\n\n- **Internships**: Actively seek internship opportunities, even if they're not initially paid. These are gateways to practical experience.\n- **Networking at college**: Engage with colleagues and professors. Being active in academic projects and study groups can also increase your visibility.\n- **Professional attitude**: Show yourself as helpful, collaborative, and reliable. The way you interact with others and your willingness to help can create a lasting impression.\n\n**For self-taught learners**\n\nIf you went the self-taught route, start by praying for luck. And while it doesn't come, learn, produce, and participate.\n\n- **Continuous education**: Invest in online courses, workshops, and bootcamps that offer recognizable credentials. Prioritize those that provide practical skills and portfolio projects.\n- **Personal and open-source projects**: Contribute to open-source projects or develop your own projects. This not only shows your technical capability but also your initiative and passion for the field.\n- **Visibility at events**: Actively participate in meetups, conferences, and IT seminars. Every interaction is an opportunity to build your network.\n\n**For professionals between jobs**\n\n- **Analysis and reflection**: Review your previous work experiences. Identify areas for improvement and seek resources to develop these skills.\n- **Stay active**: Continue applying what you've learned and sharing your knowledge. Blogs, video tutorials, and forum participation can keep your market presence warm.\n- **Networking**: Keep in touch with former colleagues, professors, and mentors. They can be valuable sources of references and future opportunities.\n\n**For Employed Professionals**\n\nRemember that your career is the priority, even while contributing to company goals. Each task and challenge not only advances the organization but also strengthens your professional trajectory. Take responsibility for developing your career to ensure long-term success.\n\nCultivate your work environment:\n\n- **Build Relationships**: Maintain good relationships with colleagues and managers and demonstrate leadership, regardless of your position.\n- **Work Ethic**: Be known for your ethics and team spirit, which can open doors to future opportunities.\n\nAdopt continuous development:\n\n- **Constant Education**: Invest in learning new technologies and trends, participating in relevant courses and certifications.\n- **Feedback and Self-Assessment**: Request feedback regularly and use it to direct your personal development.\n\nBy implementing these practices, you not only advance in your career but also contribute significantly to the success of the team and the company.\n\n## Conclusion\n\nTranscending invisibility in the job market is a considerable challenge, but absolutely achievable. A well-cultivated career can become a continuous source of opportunities. For this, it's essential to invest daily in your professional development.\n\nCultivate, plant, and prosper in your professional trajectory, transforming each action into a step from shadow toward realization and success.\n\nWhile awaiting the results of these efforts, stay active in hunting for new opportunities — pursue them with determination and tenacity, as if your life depended on it. Because, in fact, it does.\n",
      "html": "<p>I saw <a href=\"https://www.linkedin.com/posts/pjmaciel_um-desabafo-sobre-a-ti-e-o-tech-recruiter-activity-7224531473201037313-_KIJ\">this LinkedIn post by Pablo Jorge Maciel</a>, where he vents and questions why, despite being qualified, he's still invisible to the job market. I related strongly to what he said. So I decided to write this post to share my thoughts on the subject with you.</p>\n<p>There are two ways to get a job: hunting and farming.</p>\n<p>I saw this definition on Twitter (<em>I'll never call it X</em>), in this thread by <a href=\"https://x.com/SergioRocks/status/1811386383258272092\">@SergioRocks</a>, and I thought it was really good.</p>\n<p>Hunting is when you actively go after work. It's when you send your resume, when you apply. It's when you network, when you go to events, when you introduce yourself. It's when you cold call, when you message on LinkedIn. It's when you interview, when you take tests. It's when you chase it down.</p>\n<p>Farming is when you \"cultivate\" good relationships and reputation until the fruits start falling at your feet and you start being called, referred, and invited. Sounds good, right?</p>\n<p>The problem is that farming takes time and considerable effort. This means we have to rely much more on hunting in the short term than on farming. This emphasis on hunting can lead to forgetting farming practices, resulting in invisibility in the job market.</p>\n<h2>The problem with hunting</h2>\n<p>Hunting seems to offer more immediate results, but it takes a lot of work, consumes a lot of time, and the return rate is ridiculously low.</p>\n<p>The practice of hunting can be compared to selling a product to individuals who don't know the seller: it's a numbers game and you're going to send your resume to MANY job openings. A LOT. In the hundreds. Maybe even thousands. And you'll do this knowing you'll get a pitiful return.</p>\n<p>And why is it like this? Because the hunting sales funnel is cruel.</p>\n<h3>The hunting sales funnel</h3>\n<p>We can say that hunting is a sales funnel. And, like any sales funnel, it has several stages and has a conversion rate. The issue here is that the hunting conversion rate, by nature, is very low.</p>\n<p>For starters, a significant portion of job postings are ghost positions. Your resume won't even be read. There isn't even anyone on the other side. This position was created to meet a quota, to justify a budget, to create volume, or to give the impression that the company is growing. And you have no way of knowing which ones these are.</p>\n<p>Of those remaining, the ones that aren't ghosts, you probably won't get past the ATS automated screening stage. Yes, an AI will block you, because it can't read your resume, especially if it has columns, decorations, and embellishments. In this regard, the simpler the resume layout, the better. Avoid using columns, tables, graphs, images, icons, colors, different fonts, etc. It's also recommended to use file formats easily readable by artificial intelligence systems, such as .docx or PDF. Check out <a href=\"https://github.com/josenaldo\">my GitHub for a resume example I use</a>. Feel free to download and use it.</p>\n<p>In the next stage, you fight against time. If you apply for a position that received hundreds of applications, do you really think the recruitment team, with tight deadlines and few available people, will have time to read all the selected ones? If you arrived at the end of the line, the chance of even being seen is high.</p>\n<p>In short, your chance of finding a real position, being selected by the ATS, being seen by the recruiter, and being called for an interview is very low. And if you reach this stage, you'll still have to go through the gauntlet to prove you're good enough and better than other candidates.</p>\n<h3>How to beat this funnel?</h3>\n<p>Patience, determination, resilience, persistence, and NUMBERS.</p>\n<p>There's lots of advice out there, but I'll summarize here:</p>\n<ul>\n<li>Simplify your resume</li>\n<li>Prefer ATS-compatible file formats, like PDF</li>\n<li>Focus on positions well-aligned with your skills</li>\n<li>Give preference to:\n<ul>\n<li>more recent positions (the chance of old positions being ghosts is higher)</li>\n<li>positions with fewer applications (the chance of being seen is higher)</li>\n</ul>\n</li>\n<li>Apply to as many positions as possible. Keep sending resumes until your email provider starts suspecting you're trying to communicate with another planet.</li>\n</ul>\n<p>There's not much way around it. If you need to find a job, you're going to have to sweat. However, while hunting is essential for an active and immediate search for opportunities, it shouldn't be the only strategy adopted.</p>\n<h2>And farming?</h2>\n<p>So... You don't want to spend the rest of your life hunting, right?</p>\n<p>While hunting may seem like the most straightforward strategy for entering the job market, it's important to recognize the value of farming. The latter can be seen as a long-term investment in your career. By cultivating relationships and building a solid reputation, you establish fertile ground that, over time, will bring opportunities to you more naturally and frequently. Thus, while hunting seeks immediate results, farming paves the way for future and sustainable opportunities. Therefore, let's plant!</p>\n<p>But what exactly does 'planting' mean in the context of employability?</p>\n<p>Think of your career as a garden that needs to be cared for and cultivated to flourish. Just like a garden, your professional trajectory doesn't grow by chance; it requires attention, planning, and continuous care.</p>\n<p>Imagine your work is like growing food: instead of depending on sporadic hunting trips, which can be uncertain and inconsistent, you develop a fertile field. This field, carefully maintained, begins to produce food regularly, providing a sustainable and reliable source of nutrition.</p>\n<p>How do you apply this metaphor to your professional life?</p>\n<p>You 'plant' by building and cultivating your reputation and your network.</p>\n<ul>\n<li><strong>Cultivating your reputation</strong>: This is about demonstrating your competence and reliability through consistent, high-quality work. Each successfully completed project, each positive feedback, and each innovative solution you offer are like seeds germinating in your professional field.</li>\n<li><strong>Expanding your network</strong>: Relating to other professionals is like watering and nourishing the soil. Participating in industry events, interacting on professional social media platforms, and collaborating on projects are ways to keep your 'field' healthy and productive. Each connection is a root that deepens into the soil of your career, bringing stability and opening new paths for opportunities.</li>\n</ul>\n<p>Here, patience is crucial. Just as a field doesn't produce an immediate harvest, networking and building a solid reputation take time and persistence. But once established, they provide valuable resources that can sustain your career for many years.</p>\n<h3>Cultivating your reputation in IT</h3>\n<p>In the IT field, reputation is intangible capital, but of invaluable worth. It functions as a currency in the vast technology job market, where professionals are continuously evaluated for their competencies and integrity. Being recognized as a good professional can open doors and facilitate recommendations; on the other hand, a negative reputation can create almost insurmountable barriers.</p>\n<h4>Investing in building a solid reputation</h4>\n<ul>\n<li><strong>Consistent Quality</strong>: The foundation of a good reputation starts with the consistent delivery of quality work. In IT, this means writing clean code, properly documenting your projects, and meeting deadlines. Every detail counts when your work is under scrutiny.</li>\n<li><strong>Problem Solving</strong>: Stand out as someone who not only identifies problems but who brings effective solutions. The ability to solve challenges creatively and efficiently is highly valued in the dynamic IT environment.</li>\n<li><strong>Continuous Learning</strong>: The technology field is always evolving, and staying updated with the latest technologies and practices is fundamental. Participating in courses, workshops, and seminars not only expands your knowledge but also demonstrates your commitment to self-development.</li>\n<li><strong>Collaboration and Communication</strong>: IT frequently involves teamwork. Being a team player who communicates clearly and contributes to collective success strengthens your reputation as someone reliable and collaborative.</li>\n</ul>\n<h4>Building your sphere of influence</h4>\n<ul>\n<li><strong>Effective Networking</strong>: Attend industry events, join professional groups, and interact on digital platforms specific to IT professionals. These spaces are ideal for demonstrating your expertise and learning from others.</li>\n<li><strong>Contributions and Participation</strong>: Contribute to open-source projects, publish articles about your areas of expertise, and participate in discussion forums. These activities put your name in circulation within the technology community and contribute to an image of an engaged and active professional.</li>\n<li><strong>Feedback and Endorsements</strong>: Ask for feedback regularly and accept constructive criticism. Endorsements from colleagues and superiors on platforms like LinkedIn can also validate your skills and strengthen your reputation.</li>\n</ul>\n<p>Remember that building a reputation takes time and requires continuous effort. You don't need to be a digital influencer or a technology genius, but it's crucial that your peers and industry leaders trust your ability to deliver results and contribute positively. By cultivating your reputation daily, you sow the seeds for a lasting and rewarding career in IT.</p>\n<h3>The empty field problem</h3>\n<p>Many professionals at the beginning of their careers face a common dilemma: the lack of reputation and network. Without an established work history, they find themselves in what can be described as a \"catch-22\" — they don't have a reputation because they don't have work, and they can't get work because they don't have a reputation.</p>\n<h4>Breaking the cycle</h4>\n<p>To overcome this challenge, it's crucial to understand that your reputation is intrinsically linked to your results. If traditional results aren't yet an option, you need to create opportunities for yourself.</p>\n<p><strong>If you chose the academic path</strong></p>\n<p>You don't go to college to make friends, but to become a qualified professional. Therefore, make the most of your academic experience.</p>\n<ul>\n<li><strong>Internships</strong>: Actively seek internship opportunities, even if they're not initially paid. These are gateways to practical experience.</li>\n<li><strong>Networking at college</strong>: Engage with colleagues and professors. Being active in academic projects and study groups can also increase your visibility.</li>\n<li><strong>Professional attitude</strong>: Show yourself as helpful, collaborative, and reliable. The way you interact with others and your willingness to help can create a lasting impression.</li>\n</ul>\n<p><strong>For self-taught learners</strong></p>\n<p>If you went the self-taught route, start by praying for luck. And while it doesn't come, learn, produce, and participate.</p>\n<ul>\n<li><strong>Continuous education</strong>: Invest in online courses, workshops, and bootcamps that offer recognizable credentials. Prioritize those that provide practical skills and portfolio projects.</li>\n<li><strong>Personal and open-source projects</strong>: Contribute to open-source projects or develop your own projects. This not only shows your technical capability but also your initiative and passion for the field.</li>\n<li><strong>Visibility at events</strong>: Actively participate in meetups, conferences, and IT seminars. Every interaction is an opportunity to build your network.</li>\n</ul>\n<p><strong>For professionals between jobs</strong></p>\n<ul>\n<li><strong>Analysis and reflection</strong>: Review your previous work experiences. Identify areas for improvement and seek resources to develop these skills.</li>\n<li><strong>Stay active</strong>: Continue applying what you've learned and sharing your knowledge. Blogs, video tutorials, and forum participation can keep your market presence warm.</li>\n<li><strong>Networking</strong>: Keep in touch with former colleagues, professors, and mentors. They can be valuable sources of references and future opportunities.</li>\n</ul>\n<p><strong>For Employed Professionals</strong></p>\n<p>Remember that your career is the priority, even while contributing to company goals. Each task and challenge not only advances the organization but also strengthens your professional trajectory. Take responsibility for developing your career to ensure long-term success.</p>\n<p>Cultivate your work environment:</p>\n<ul>\n<li><strong>Build Relationships</strong>: Maintain good relationships with colleagues and managers and demonstrate leadership, regardless of your position.</li>\n<li><strong>Work Ethic</strong>: Be known for your ethics and team spirit, which can open doors to future opportunities.</li>\n</ul>\n<p>Adopt continuous development:</p>\n<ul>\n<li><strong>Constant Education</strong>: Invest in learning new technologies and trends, participating in relevant courses and certifications.</li>\n<li><strong>Feedback and Self-Assessment</strong>: Request feedback regularly and use it to direct your personal development.</li>\n</ul>\n<p>By implementing these practices, you not only advance in your career but also contribute significantly to the success of the team and the company.</p>\n<h2>Conclusion</h2>\n<p>Transcending invisibility in the job market is a considerable challenge, but absolutely achievable. A well-cultivated career can become a continuous source of opportunities. For this, it's essential to invest daily in your professional development.</p>\n<p>Cultivate, plant, and prosper in your professional trajectory, transforming each action into a step from shadow toward realization and success.</p>\n<p>While awaiting the results of these efforts, stay active in hunting for new opportunities — pursue them with determination and tenacity, as if your life depended on it. Because, in fact, it does.</p>"
    },
    "_id": "blog/en/why-am-i-still-invisible.md",
    "_raw": {
      "sourceFilePath": "blog/en/why-am-i-still-invisible.md",
      "sourceFileName": "why-am-i-still-invisible.md",
      "sourceFileDir": "blog/en",
      "contentType": "markdown",
      "flattenedPath": "blog/en/why-am-i-still-invisible"
    },
    "type": "Post",
    "locale": "en",
    "slug": "why-am-i-still-invisible",
    "url": "/blog/why-am-i-still-invisible"
  },
  {
    "title": "AI and Developers: Another Brick or Another Floor?",
    "description": "AI will shake the market — that much is certain. Whether it walls developers in or elevates them depends on a timescale most people forget to consider.",
    "date": "2026-02-22T12:25:00.000Z",
    "author": "Josenaldo Matos",
    "category": "opinion",
    "image": "/images/blog/ai-and-developers-another-brick-or-another-floor.png",
    "body": {
      "raw": "\nI'll be honest with you from the start: I don't know what will happen.\n\nNobody does.\n\nAnyone who tells you with certainty that AI will eliminate developers — or that developers have nothing to worry about — is selling you something. Probably confidence they don't have.\n\nWhat I *can* do is look backwards. And when I do, I see a pattern that keeps repeating, wave after wave, technology after technology.\n\nThat pattern is what this article is about.\n\n---\n\n## Two Metaphors, One Conflict\n\nPink Floyd sang *\"Another Brick in the Wall\"* — a song about systems that imprison, dehumanize, flatten people into components of something that doesn't serve them.\n\nWhen I look at how AI is being deployed *today*, in a capitalist market driven by short-term results, I see that metaphor playing out in real time:\n\n* Junior developers being replaced before they ever become seniors.\n* Hiring freezes justified by \"AI can do that now.\"\n* Power concentrating in the hands of whoever controls the models.\n* Professionals — real people — absorbing the cost of a transition they didn't choose.\n\nThat's the brick.\n\nBut there's another metaphor. Software engineering is like a skyscraper under construction. Each era adds a new floor of abstraction:\n\n* Machine code. Assembly. Operating systems.\n* High-level languages. Frameworks. Cloud platforms.\n* And now: AI-assisted development.\n\nEach new floor didn't demolish what was below. It raised the building higher — and made the foundation *more* critical, not less. The higher the structure, the more pressure on the ground it stands on.\n\nThat's the floor.\n\nBoth metaphors are true. The conflict between them is the actual question.\n\n---\n\n## The Short Term Is the Brick\n\nLet's not skip past this too quickly.\n\nThe disruption is real. It's happening now. It will get worse before it stabilizes.\n\nWhen a new abstraction layer arrives this fast, the market doesn't smoothly redistribute workers — it shakes the building. People fall. Roles that existed last year disappear before new ones are clearly defined. The people who absorb the cost most aren't the ones at the top making the decisions.\n\nThis isn't pessimism. It's pattern recognition.\n\nThe cloud computing wave didn't warn sysadmins before it arrived. Mobile didn't send a memo to desktop developers. Each wave produced genuine disruption, real unemployment, real anxiety — concentrated in the people least positioned to adapt quickly.\n\nAI is doing the same thing, and it would be dishonest to pretend otherwise.\n\n---\n\n## The Long Term Is the Floor\n\nBut here's what the pattern also shows, consistently, across every technological wave:\n\n**The market eventually expands more than it contracts.**\n\nHigh-level languages didn't eliminate systems engineers — they created millions of new developers who never would have learned assembly. Frameworks didn't kill backend developers — they made it economically viable to build software that previously wouldn't have been built at all. The cloud didn't eliminate infrastructure expertise — it created an entirely new discipline, massively scaled it, and produced demand for kernel engineers that hadn't existed before.\n\nWe eliminated typists. We employed vastly more people typing.\n\nEach wave lowered the cost of creation. And because creation became cheaper, more things got created. More systems, more complexity, more edge cases, more infrastructure — and therefore, more demand for people who understand what's happening underneath.\n\nAI follows the same trajectory.\n\nIt lowers the cost of building software. That means more software will be built. More systems will interact in unexpected ways. More abstractions will leak. More performance limits will be reached. And when they do — someone will need to go downstairs.\n\nSomeone always debugs the runtime.\nSomeone investigates the memory behavior.\nSomeone reads the logs nobody else understands.\n\nHigher abstraction doesn't reduce the need for expertise. It creates demand for deeper expertise.\n\n---\n\n## The Real Question Isn't \"Will AI Replace Developers?\"\n\nThat's the wrong question.\n\nThe right question is: **how long does the brick phase last before the floor phase begins?**\n\nBecause both are coming. The brick is here now. The floor is being built underneath us whether we acknowledge it or not.\n\nAnd between those two phases — in the transition, in the turbulence — is where careers are won or lost. Where some people fall off the building and others figure out which floor they're building next.\n\n---\n\n## How to Survive the Wave When It's Your Side That's Threatened\n\nI don't have a formula. But I can share what the pattern suggests.\n\n**Don't mistake the wave for the ocean.**\n\nThe wave is violent and disorienting. It feels like destruction. But waves move through the water — they don't replace it. The underlying dynamics of software complexity, the need for people who understand systems, the value of judgment over mere execution — those don't disappear. They become more scarce, and therefore more valuable.\n\n**Understand the floor below you.**\n\nEvery new abstraction creates distance from the layers underneath. The developers who survive transitions — and who gain leverage in the new world — are the ones who can go downstairs when the abstraction fails. Knowing *why* something works is more durable than knowing *how* to operate a tool that might not exist next year.\n\n**Position yourself at the boundary.**\n\nThe most valuable place in any technological transition isn't at the old layer or the new one — it's at the boundary between them. Understanding how AI tools work, where they fail, how they compose with existing systems, what they can't reason about — that's where judgment lives. And judgment doesn't get automated easily.\n\n**Acknowledge the cost of transition — in yourself and in others.**\n\nIf you're in a position of privilege in this wave — senior, established, with runway — use it to help people who aren't. The expansion of the market is not evenly distributed. Mentorship, advocacy, honest writing about what's actually happening: these matter.\n\n---\n\n## The Building Keeps Growing\n\nI can't tell you when the brick phase ends. I can't tell you exactly what the new floor looks like, or what your role will be on it.\n\nWhat I can tell you is this: every previous wave that felt like the end of software development turned out to be the beginning of a larger one. The building didn't fall — it grew taller. And a taller building needs more engineers, not fewer.\n\nAI is not the end of programming.\n\nIt's another floor in a building that has been under construction for decades.\n\nThe question isn't whether you'll have a place in it.\n\nThe question is which floor you'll choose to build.\n",
      "html": "<p>I'll be honest with you from the start: I don't know what will happen.</p>\n<p>Nobody does.</p>\n<p>Anyone who tells you with certainty that AI will eliminate developers — or that developers have nothing to worry about — is selling you something. Probably confidence they don't have.</p>\n<p>What I <em>can</em> do is look backwards. And when I do, I see a pattern that keeps repeating, wave after wave, technology after technology.</p>\n<p>That pattern is what this article is about.</p>\n<hr>\n<h2>Two Metaphors, One Conflict</h2>\n<p>Pink Floyd sang <em>\"Another Brick in the Wall\"</em> — a song about systems that imprison, dehumanize, flatten people into components of something that doesn't serve them.</p>\n<p>When I look at how AI is being deployed <em>today</em>, in a capitalist market driven by short-term results, I see that metaphor playing out in real time:</p>\n<ul>\n<li>Junior developers being replaced before they ever become seniors.</li>\n<li>Hiring freezes justified by \"AI can do that now.\"</li>\n<li>Power concentrating in the hands of whoever controls the models.</li>\n<li>Professionals — real people — absorbing the cost of a transition they didn't choose.</li>\n</ul>\n<p>That's the brick.</p>\n<p>But there's another metaphor. Software engineering is like a skyscraper under construction. Each era adds a new floor of abstraction:</p>\n<ul>\n<li>Machine code. Assembly. Operating systems.</li>\n<li>High-level languages. Frameworks. Cloud platforms.</li>\n<li>And now: AI-assisted development.</li>\n</ul>\n<p>Each new floor didn't demolish what was below. It raised the building higher — and made the foundation <em>more</em> critical, not less. The higher the structure, the more pressure on the ground it stands on.</p>\n<p>That's the floor.</p>\n<p>Both metaphors are true. The conflict between them is the actual question.</p>\n<hr>\n<h2>The Short Term Is the Brick</h2>\n<p>Let's not skip past this too quickly.</p>\n<p>The disruption is real. It's happening now. It will get worse before it stabilizes.</p>\n<p>When a new abstraction layer arrives this fast, the market doesn't smoothly redistribute workers — it shakes the building. People fall. Roles that existed last year disappear before new ones are clearly defined. The people who absorb the cost most aren't the ones at the top making the decisions.</p>\n<p>This isn't pessimism. It's pattern recognition.</p>\n<p>The cloud computing wave didn't warn sysadmins before it arrived. Mobile didn't send a memo to desktop developers. Each wave produced genuine disruption, real unemployment, real anxiety — concentrated in the people least positioned to adapt quickly.</p>\n<p>AI is doing the same thing, and it would be dishonest to pretend otherwise.</p>\n<hr>\n<h2>The Long Term Is the Floor</h2>\n<p>But here's what the pattern also shows, consistently, across every technological wave:</p>\n<p><strong>The market eventually expands more than it contracts.</strong></p>\n<p>High-level languages didn't eliminate systems engineers — they created millions of new developers who never would have learned assembly. Frameworks didn't kill backend developers — they made it economically viable to build software that previously wouldn't have been built at all. The cloud didn't eliminate infrastructure expertise — it created an entirely new discipline, massively scaled it, and produced demand for kernel engineers that hadn't existed before.</p>\n<p>We eliminated typists. We employed vastly more people typing.</p>\n<p>Each wave lowered the cost of creation. And because creation became cheaper, more things got created. More systems, more complexity, more edge cases, more infrastructure — and therefore, more demand for people who understand what's happening underneath.</p>\n<p>AI follows the same trajectory.</p>\n<p>It lowers the cost of building software. That means more software will be built. More systems will interact in unexpected ways. More abstractions will leak. More performance limits will be reached. And when they do — someone will need to go downstairs.</p>\n<p>Someone always debugs the runtime.\nSomeone investigates the memory behavior.\nSomeone reads the logs nobody else understands.</p>\n<p>Higher abstraction doesn't reduce the need for expertise. It creates demand for deeper expertise.</p>\n<hr>\n<h2>The Real Question Isn't \"Will AI Replace Developers?\"</h2>\n<p>That's the wrong question.</p>\n<p>The right question is: <strong>how long does the brick phase last before the floor phase begins?</strong></p>\n<p>Because both are coming. The brick is here now. The floor is being built underneath us whether we acknowledge it or not.</p>\n<p>And between those two phases — in the transition, in the turbulence — is where careers are won or lost. Where some people fall off the building and others figure out which floor they're building next.</p>\n<hr>\n<h2>How to Survive the Wave When It's Your Side That's Threatened</h2>\n<p>I don't have a formula. But I can share what the pattern suggests.</p>\n<p><strong>Don't mistake the wave for the ocean.</strong></p>\n<p>The wave is violent and disorienting. It feels like destruction. But waves move through the water — they don't replace it. The underlying dynamics of software complexity, the need for people who understand systems, the value of judgment over mere execution — those don't disappear. They become more scarce, and therefore more valuable.</p>\n<p><strong>Understand the floor below you.</strong></p>\n<p>Every new abstraction creates distance from the layers underneath. The developers who survive transitions — and who gain leverage in the new world — are the ones who can go downstairs when the abstraction fails. Knowing <em>why</em> something works is more durable than knowing <em>how</em> to operate a tool that might not exist next year.</p>\n<p><strong>Position yourself at the boundary.</strong></p>\n<p>The most valuable place in any technological transition isn't at the old layer or the new one — it's at the boundary between them. Understanding how AI tools work, where they fail, how they compose with existing systems, what they can't reason about — that's where judgment lives. And judgment doesn't get automated easily.</p>\n<p><strong>Acknowledge the cost of transition — in yourself and in others.</strong></p>\n<p>If you're in a position of privilege in this wave — senior, established, with runway — use it to help people who aren't. The expansion of the market is not evenly distributed. Mentorship, advocacy, honest writing about what's actually happening: these matter.</p>\n<hr>\n<h2>The Building Keeps Growing</h2>\n<p>I can't tell you when the brick phase ends. I can't tell you exactly what the new floor looks like, or what your role will be on it.</p>\n<p>What I can tell you is this: every previous wave that felt like the end of software development turned out to be the beginning of a larger one. The building didn't fall — it grew taller. And a taller building needs more engineers, not fewer.</p>\n<p>AI is not the end of programming.</p>\n<p>It's another floor in a building that has been under construction for decades.</p>\n<p>The question isn't whether you'll have a place in it.</p>\n<p>The question is which floor you'll choose to build.</p>"
    },
    "_id": "blog/pt/ai-and-developers-another-brick-or-another-floor.md",
    "_raw": {
      "sourceFilePath": "blog/pt/ai-and-developers-another-brick-or-another-floor.md",
      "sourceFileName": "ai-and-developers-another-brick-or-another-floor.md",
      "sourceFileDir": "blog/pt",
      "contentType": "markdown",
      "flattenedPath": "blog/pt/ai-and-developers-another-brick-or-another-floor"
    },
    "type": "Post",
    "locale": "pt",
    "slug": "ai-and-developers-another-brick-or-another-floor",
    "url": "/blog/ai-and-developers-another-brick-or-another-floor"
  },
  {
    "title": "The first draft of Programação Orientada a Gambiarra",
    "description": "A short update on my first complete draft, and what this book is really about.",
    "date": "2026-02-19T03:00:00.000Z",
    "author": "Josenaldo Matos",
    "category": "personal",
    "image": "/images/blog/programacao-orientada-a-gambiarra-first-draft.png",
    "body": {
      "raw": "\nI just finished the first complete draft of [**Programação Orientada a Gambiarra** - https://livropog.com.br/](https://livropog.com.br/).\n\nIf you’re not Brazilian, the word _gambiarra_ might sound mysterious. It’s the kind of improvised fix you do when reality doesn’t match the plan: a workaround, a hack, a duct-tape solution. It can be brilliant, dangerous, embarrassing, or all of the above.\n\nThis book is not a celebration of messy code. It’s an attempt to describe something we all do (especially under deadlines): we bend constraints. The core idea is simple: a “gambiarra” becomes less harmful when it is _oriented_—when you treat it as a deliberate design decision with context, boundaries, and a cleanup strategy.\n\nIn the draft, I try to answer questions like:\n\n- When is a shortcut acceptable, and when is it just technical debt disguised as courage?\n- How do you document a workaround so the next person doesn’t turn it into a permanent architecture?\n- What makes a quick fix safe enough to ship, and what makes it a production incident waiting to happen?\n\nYou’ll find stories and patterns: how to create “escape hatches” without turning your system into a maze, how to choose the smallest change that reduces risk, and how to communicate trade-offs without guilt-tripping yourself or your team.\n\nThe first draft is rough, but it’s complete. Now comes the hard part: cutting fluff, tightening examples, and making sure every chapter helps you build software that survives reality—without pretending reality is tidy.\n",
      "html": "<p>I just finished the first complete draft of <a href=\"https://livropog.com.br/\"><strong>Programação Orientada a Gambiarra</strong> - https://livropog.com.br/</a>.</p>\n<p>If you’re not Brazilian, the word <em>gambiarra</em> might sound mysterious. It’s the kind of improvised fix you do when reality doesn’t match the plan: a workaround, a hack, a duct-tape solution. It can be brilliant, dangerous, embarrassing, or all of the above.</p>\n<p>This book is not a celebration of messy code. It’s an attempt to describe something we all do (especially under deadlines): we bend constraints. The core idea is simple: a “gambiarra” becomes less harmful when it is <em>oriented</em>—when you treat it as a deliberate design decision with context, boundaries, and a cleanup strategy.</p>\n<p>In the draft, I try to answer questions like:</p>\n<ul>\n<li>When is a shortcut acceptable, and when is it just technical debt disguised as courage?</li>\n<li>How do you document a workaround so the next person doesn’t turn it into a permanent architecture?</li>\n<li>What makes a quick fix safe enough to ship, and what makes it a production incident waiting to happen?</li>\n</ul>\n<p>You’ll find stories and patterns: how to create “escape hatches” without turning your system into a maze, how to choose the smallest change that reduces risk, and how to communicate trade-offs without guilt-tripping yourself or your team.</p>\n<p>The first draft is rough, but it’s complete. Now comes the hard part: cutting fluff, tightening examples, and making sure every chapter helps you build software that survives reality—without pretending reality is tidy.</p>"
    },
    "_id": "blog/pt/first-draft-programacao-orientada-a-gambiarra.md",
    "_raw": {
      "sourceFilePath": "blog/pt/first-draft-programacao-orientada-a-gambiarra.md",
      "sourceFileName": "first-draft-programacao-orientada-a-gambiarra.md",
      "sourceFileDir": "blog/pt",
      "contentType": "markdown",
      "flattenedPath": "blog/pt/first-draft-programacao-orientada-a-gambiarra"
    },
    "type": "Post",
    "locale": "pt",
    "slug": "first-draft-programacao-orientada-a-gambiarra",
    "url": "/blog/first-draft-programacao-orientada-a-gambiarra"
  },
  {
    "title": "Interfaces aren't villains",
    "description": "A technical and architectural analysis on the value of defining explicit contracts even when there's only one concrete implementation.",
    "date": "2025-12-24T12:00:00.000Z",
    "author": "Josenaldo Matos",
    "category": "architecture",
    "image": "/images/blog/interfaces-arent-villains.png",
    "body": {
      "raw": "\nThere's a growing narrative in engineering teams: \"let's not create an interface now because that's overengineering.\"\n\nIt stems from a real frustration. Many projects accumulate unnecessary layers just to \"look like architecture.\" And when change never comes, all that's left is a sense of waste.\n\nThe criticism is valid. The diagnosis, not always.\n\nThe right target isn't the interface itself. It's speculative abstraction: the kind that doesn't protect a real boundary and doesn't reduce impact.\n\nInterfaces don't exist to \"predict the future.\"\nInterfaces exist to **limit the impact of the present**.\n\nPractical rule: if a contract reduces surface area and protects a boundary, it's worth it. If it just changes syntax without protecting anyone, it becomes decoration.\n\n---\n\n## Where the criticism hits — and where it misses\n\nIt hits when it calls out:\n\n- abstractions created without need\n- layers that protect nothing\n- \"cosmetic complexity\" to look professional\n\nBut it misses when it concludes that:\n\n- \"if there's only one implementation, don't use an interface\"\n- \"interfaces only exist to swap vendors\"\n- \"this violates YAGNI\"\n\nIn reality, this conclusion becomes dangerous because it conflates different concepts:\n\n| Thing        | What it is                     | Benefit                 | Cost   | When to use                    |\n| ------------ | ------------------------------ | ----------------------- | ------ | ------------------------------ |\n| Interface    | Boundary contract              | Reduces external impact | Low    | Dependencies and exposure      |\n| Abstraction  | Way to organize solution space | Medium                  | Medium | When concrete variation exists |\n| Extra layers | Speculative structure          | Low/Uncertain           | High   | Only with proven need          |\n\n**Creating an interface ≠ creating layers.**\n\nThis contrast shows that an interface, by itself, doesn't add significant architectural weight.\n\nWhat makes maintenance expensive is building structures that don't delineate real boundaries. Interfaces act as contracts that stabilize interactions; extra layers are born to accommodate scenarios that may never exist.\n\nConflating these elements leads to reactive decisions: useful interfaces are eliminated to avoid excesses that should be prevented with design discipline.\n\n---\n\n## Without an interface: the hidden problem\n\n```java\nclass CheckoutService {\n    private final ThirdPartySDK sdk;\n\n    CheckoutService(ThirdPartySDK sdk) {\n        this.sdk = sdk;\n    }\n\n    public PaymentResponse pay(PaymentRequest req) {\n        return sdk.execute(req); // direct dependency\n    }\n}\n```\n\nWhat's happening here?\n\n- The part of the system that should be stable depends directly on an external API outside our control.\n- No barrier prevents SDK decisions from leaking into the system.\n- Swapping vendors, updating versions, or handling a breaking change becomes surgery.\n\nEverything works — until the day it doesn't.\n\nThe absence of an explicit contract leads to erosive coupling. Every place that touches `ThirdPartySDK` replicates assumptions about parameters, exception handling, and response semantics. Architectural knowledge spreads across code fragments, the team loses visibility of critical dependencies, and the cost of change explodes. The system gains accidental complexity without gaining any protective mechanism.\n\nThe most insidious part is that this seems cheap at first: no extra file, no \"contract.\" The cost appears later, when the dependency changes and you discover how many places knew too much.\n\n---\n\n## With an interface: the explicit contract\n\n```java\npublic interface PaymentGateway {\n    PaymentResponse pay(PaymentRequest req);\n}\n\npublic class ThirdPartyPaymentGateway implements PaymentGateway {\n    private final ThirdPartySDK sdk;\n\n    public ThirdPartyPaymentGateway(ThirdPartySDK sdk) {\n        this.sdk = sdk;\n    }\n\n    @Override\n    public PaymentResponse pay(PaymentRequest req) {\n        return sdk.execute(req);\n    }\n}\n\npublic class CheckoutService {\n    private final PaymentGateway gateway;\n\n    public CheckoutService(PaymentGateway gateway) {\n        this.gateway = gateway;\n    }\n\n    public PaymentResponse pay(PaymentRequest req) {\n        return gateway.pay(req);\n    }\n}\n```\n\nImmediate benefits:\n\n- the external dependency is isolated\n- the public surface is smaller and clearer\n- the system core doesn't know the vendor\n- swapping the SDK is local work, not systemic\n- testing becomes simpler (test doubles without SDK)\n\n**None of this requires a second implementation.**\nThe interface adds value even when it's unique.\n\nInterfaces bring cognitive clarity: they establish a ubiquitous language for essential behavior and create a controlled extension point.\n\nThe concrete implementation remains unique, but the reverse coupling (from system core to vendor) disappears. Even if substitution never happens, the team benefits today from simpler tests, clearer SRP, and implicit contract documentation.\n\n---\n\n## Where this lives in architecture\n\n- **Clean Architecture**: the interface is a boundary; the adapter is a detail.\n- **Hexagonal**: the interface is a port; the implementation is an adapter.\n- **Spring**: the contract enables IoC/DI without tight coupling.\n- **DDD**: the contract is part of the bounded context, not the implementation.\n\nThe interface doesn't predict change.\nIt makes change possible.\n\nBy placing the interface inside the policy circle (or domain), we ensure the external side takes responsibility for variation. This aligns architectural design with principles like Dependency Inversion and reinforces the autonomy of core modules. Unit tests come to depend on simple test doubles; integrations take on an explicit role as adapters, with their own lifecycle and observability.\n\nIf you need a simple heuristic: the interface usually belongs to whoever wants stability (the consumer). The vendor becomes a detail that implements the contract.\n\n---\n\n## The change nobody predicted: software rot\n\nThere is a class of change that rarely appears in the \"should I use an interface?\" debate, even though it's arguably the most certain one: **the software itself will decay.**\n\nNot because your team makes bad decisions. Not because requirements are unclear. Simply because the world around the code keeps moving.\n\nConsider what happens over five years of a production system:\n\n- The JVM or runtime gets updated — and a dependency breaks silently.\n- The cloud provider deprecates an API version your SDK depended on.\n- A framework upgrade changes injection semantics or lifecycle contracts.\n- The database driver introduces a new behavior with the same method signature.\n- A security patch in an OS library changes how a connection pool behaves.\n\nAt no point did anyone decide to \"swap Postgres for Oracle.\" Nobody planned to change the payment vendor. Nobody wanted to touch the authentication library. But the library touched them — because that's what software does. It rots.\n\n**Software rot** (sometimes called *bit rot* or *entropy*) is the gradual degradation of a system's operational environment while the code itself stays still. The surrounding world evolves: dependencies age, platforms shift, security requirements tighten. Code that worked in 2020 may fail in 2025 without a single intentional change.\n\nThis is precisely where abstractions and separation of concerns prove their worth beyond the \"swap vendor\" scenario.\n\nWhen external dependencies sit behind a contract, adapting to rot becomes local work:\n\n- the SDK changed its exception model → you fix one adapter\n- the database driver deprecated a method → you update one implementation\n- the cloud API returned a new field → you adjust the mapping in one place\n\nWithout the interface, this same event propagates. Every place that directly touched the dependency now needs to change, be reviewed, and be retested. The scope of a library patch is no longer the library — it's the entire codebase.\n\n**The interface doesn't protect you from change. It controls where change is allowed to land.**\n\nAnd since software rot is not a risk you can avoid — only a timeline you can't predict — designing for it is not overengineering. It's maintenance discipline.\n\n---\n\n## When an interface isn't worth it\n\n- purely internal services, without exposure\n- utility objects without external dependencies\n- stable functions within a single closed module\n- when the interface doesn't reduce surface area, just changes syntax\n\nIf the interface doesn't protect anyone, it serves no purpose.\n\nCreating an empty contract just shifts responsibilities without offering real cushioning. In these scenarios, the additional cognitive cost doesn't pay off: the team needs to maintain redundant classes, search extra references, and deal with less direct diagnostics. Interfaces are tools, not ornaments. Using them outside relevant boundaries violates the very purpose of impact reduction.\n\n---\n\n## When it's (very much) worth it\n\n- boundaries with databases and messaging systems\n- integrations with external services\n- inter-module or inter-domain communications\n- architectural risk points\n- where the cost of change is high or systemic\n\nIf the interface protects the domain, it has already paid for itself.\n\nThese points share a trait: they concentrate uncertainty and risk. An explicit contract allows introducing observability metrics in the adapter, applying resilience patterns (circuit breaker, retry, fallback), and testing the domain with test doubles that simulate extreme behaviors. Even a single implementation gains elasticity: alternative versions, additional instrumentation, or migration strategies can temporarily coexist under the same contract, without exponentially increasing entropy.\n\n---\n\n## Decision checklist (use before creating)\n\n| Question                                                  | If \"yes\", create interface |\n| --------------------------------------------------------- | -------------------------- |\n| Does this component touch something I don't control?      | Yes                        |\n| Might I need to update vendor, version, or stack?         | Yes                        |\n| If this dependency breaks, does the entire system suffer? | Yes                        |\n| Does this API expose too many details?                    | Yes                        |\n| Is there risk of impact beyond the current module?        | Yes                        |\n\nIf everything is \"no\", don't create it.\nIf one is \"yes\", your interface already has a reason.\n\nThis checklist acts as a conscious design exercise. It forces the team to reflect on responsibilities, boundaries, and impact before introducing or removing contracts. More importantly: it eliminates superficial discussions in code reviews, where criticism falls on the mere existence of the interface. The debate shifts to focus on concrete risk and necessary protection.\n\n---\n\n## Executive summary\n\nInterfaces aren't about the future.\nThey're about the cost of change **today**.\n\nChange doesn't only come from architectural decisions — swapping vendors, scaling teams, adding features. It also comes from entropy: runtime upgrades, deprecated APIs, security patches, framework evolution. Software rots not because teams fail, but because the world keeps moving around static code.\n\nThe interface is the firewall between your domain logic and everything that changes without asking permission.\n\nThat boundary pays for itself long before the second implementation ever appears.\n\n- Don't create interfaces to inflate architecture.\n- Don't create abstractions to win arguments in code reviews.\n- Create contracts to protect boundaries and reduce impact.\n\nYAGNI isn't \"don't do it.\"\nYAGNI is **\"don't do what protects nothing.\"**\n",
      "html": "<p>There's a growing narrative in engineering teams: \"let's not create an interface now because that's overengineering.\"</p>\n<p>It stems from a real frustration. Many projects accumulate unnecessary layers just to \"look like architecture.\" And when change never comes, all that's left is a sense of waste.</p>\n<p>The criticism is valid. The diagnosis, not always.</p>\n<p>The right target isn't the interface itself. It's speculative abstraction: the kind that doesn't protect a real boundary and doesn't reduce impact.</p>\n<p>Interfaces don't exist to \"predict the future.\"\nInterfaces exist to <strong>limit the impact of the present</strong>.</p>\n<p>Practical rule: if a contract reduces surface area and protects a boundary, it's worth it. If it just changes syntax without protecting anyone, it becomes decoration.</p>\n<hr>\n<h2>Where the criticism hits — and where it misses</h2>\n<p>It hits when it calls out:</p>\n<ul>\n<li>abstractions created without need</li>\n<li>layers that protect nothing</li>\n<li>\"cosmetic complexity\" to look professional</li>\n</ul>\n<p>But it misses when it concludes that:</p>\n<ul>\n<li>\"if there's only one implementation, don't use an interface\"</li>\n<li>\"interfaces only exist to swap vendors\"</li>\n<li>\"this violates YAGNI\"</li>\n</ul>\n<p>In reality, this conclusion becomes dangerous because it conflates different concepts:</p>\n<p>| Thing        | What it is                     | Benefit                 | Cost   | When to use                    |\n| ------------ | ------------------------------ | ----------------------- | ------ | ------------------------------ |\n| Interface    | Boundary contract              | Reduces external impact | Low    | Dependencies and exposure      |\n| Abstraction  | Way to organize solution space | Medium                  | Medium | When concrete variation exists |\n| Extra layers | Speculative structure          | Low/Uncertain           | High   | Only with proven need          |</p>\n<p><strong>Creating an interface ≠ creating layers.</strong></p>\n<p>This contrast shows that an interface, by itself, doesn't add significant architectural weight.</p>\n<p>What makes maintenance expensive is building structures that don't delineate real boundaries. Interfaces act as contracts that stabilize interactions; extra layers are born to accommodate scenarios that may never exist.</p>\n<p>Conflating these elements leads to reactive decisions: useful interfaces are eliminated to avoid excesses that should be prevented with design discipline.</p>\n<hr>\n<h2>Without an interface: the hidden problem</h2>\n<pre><code class=\"language-java\">class CheckoutService {\n    private final ThirdPartySDK sdk;\n\n    CheckoutService(ThirdPartySDK sdk) {\n        this.sdk = sdk;\n    }\n\n    public PaymentResponse pay(PaymentRequest req) {\n        return sdk.execute(req); // direct dependency\n    }\n}\n</code></pre>\n<p>What's happening here?</p>\n<ul>\n<li>The part of the system that should be stable depends directly on an external API outside our control.</li>\n<li>No barrier prevents SDK decisions from leaking into the system.</li>\n<li>Swapping vendors, updating versions, or handling a breaking change becomes surgery.</li>\n</ul>\n<p>Everything works — until the day it doesn't.</p>\n<p>The absence of an explicit contract leads to erosive coupling. Every place that touches <code>ThirdPartySDK</code> replicates assumptions about parameters, exception handling, and response semantics. Architectural knowledge spreads across code fragments, the team loses visibility of critical dependencies, and the cost of change explodes. The system gains accidental complexity without gaining any protective mechanism.</p>\n<p>The most insidious part is that this seems cheap at first: no extra file, no \"contract.\" The cost appears later, when the dependency changes and you discover how many places knew too much.</p>\n<hr>\n<h2>With an interface: the explicit contract</h2>\n<pre><code class=\"language-java\">public interface PaymentGateway {\n    PaymentResponse pay(PaymentRequest req);\n}\n\npublic class ThirdPartyPaymentGateway implements PaymentGateway {\n    private final ThirdPartySDK sdk;\n\n    public ThirdPartyPaymentGateway(ThirdPartySDK sdk) {\n        this.sdk = sdk;\n    }\n\n    @Override\n    public PaymentResponse pay(PaymentRequest req) {\n        return sdk.execute(req);\n    }\n}\n\npublic class CheckoutService {\n    private final PaymentGateway gateway;\n\n    public CheckoutService(PaymentGateway gateway) {\n        this.gateway = gateway;\n    }\n\n    public PaymentResponse pay(PaymentRequest req) {\n        return gateway.pay(req);\n    }\n}\n</code></pre>\n<p>Immediate benefits:</p>\n<ul>\n<li>the external dependency is isolated</li>\n<li>the public surface is smaller and clearer</li>\n<li>the system core doesn't know the vendor</li>\n<li>swapping the SDK is local work, not systemic</li>\n<li>testing becomes simpler (test doubles without SDK)</li>\n</ul>\n<p><strong>None of this requires a second implementation.</strong>\nThe interface adds value even when it's unique.</p>\n<p>Interfaces bring cognitive clarity: they establish a ubiquitous language for essential behavior and create a controlled extension point.</p>\n<p>The concrete implementation remains unique, but the reverse coupling (from system core to vendor) disappears. Even if substitution never happens, the team benefits today from simpler tests, clearer SRP, and implicit contract documentation.</p>\n<hr>\n<h2>Where this lives in architecture</h2>\n<ul>\n<li><strong>Clean Architecture</strong>: the interface is a boundary; the adapter is a detail.</li>\n<li><strong>Hexagonal</strong>: the interface is a port; the implementation is an adapter.</li>\n<li><strong>Spring</strong>: the contract enables IoC/DI without tight coupling.</li>\n<li><strong>DDD</strong>: the contract is part of the bounded context, not the implementation.</li>\n</ul>\n<p>The interface doesn't predict change.\nIt makes change possible.</p>\n<p>By placing the interface inside the policy circle (or domain), we ensure the external side takes responsibility for variation. This aligns architectural design with principles like Dependency Inversion and reinforces the autonomy of core modules. Unit tests come to depend on simple test doubles; integrations take on an explicit role as adapters, with their own lifecycle and observability.</p>\n<p>If you need a simple heuristic: the interface usually belongs to whoever wants stability (the consumer). The vendor becomes a detail that implements the contract.</p>\n<hr>\n<h2>The change nobody predicted: software rot</h2>\n<p>There is a class of change that rarely appears in the \"should I use an interface?\" debate, even though it's arguably the most certain one: <strong>the software itself will decay.</strong></p>\n<p>Not because your team makes bad decisions. Not because requirements are unclear. Simply because the world around the code keeps moving.</p>\n<p>Consider what happens over five years of a production system:</p>\n<ul>\n<li>The JVM or runtime gets updated — and a dependency breaks silently.</li>\n<li>The cloud provider deprecates an API version your SDK depended on.</li>\n<li>A framework upgrade changes injection semantics or lifecycle contracts.</li>\n<li>The database driver introduces a new behavior with the same method signature.</li>\n<li>A security patch in an OS library changes how a connection pool behaves.</li>\n</ul>\n<p>At no point did anyone decide to \"swap Postgres for Oracle.\" Nobody planned to change the payment vendor. Nobody wanted to touch the authentication library. But the library touched them — because that's what software does. It rots.</p>\n<p><strong>Software rot</strong> (sometimes called <em>bit rot</em> or <em>entropy</em>) is the gradual degradation of a system's operational environment while the code itself stays still. The surrounding world evolves: dependencies age, platforms shift, security requirements tighten. Code that worked in 2020 may fail in 2025 without a single intentional change.</p>\n<p>This is precisely where abstractions and separation of concerns prove their worth beyond the \"swap vendor\" scenario.</p>\n<p>When external dependencies sit behind a contract, adapting to rot becomes local work:</p>\n<ul>\n<li>the SDK changed its exception model → you fix one adapter</li>\n<li>the database driver deprecated a method → you update one implementation</li>\n<li>the cloud API returned a new field → you adjust the mapping in one place</li>\n</ul>\n<p>Without the interface, this same event propagates. Every place that directly touched the dependency now needs to change, be reviewed, and be retested. The scope of a library patch is no longer the library — it's the entire codebase.</p>\n<p><strong>The interface doesn't protect you from change. It controls where change is allowed to land.</strong></p>\n<p>And since software rot is not a risk you can avoid — only a timeline you can't predict — designing for it is not overengineering. It's maintenance discipline.</p>\n<hr>\n<h2>When an interface isn't worth it</h2>\n<ul>\n<li>purely internal services, without exposure</li>\n<li>utility objects without external dependencies</li>\n<li>stable functions within a single closed module</li>\n<li>when the interface doesn't reduce surface area, just changes syntax</li>\n</ul>\n<p>If the interface doesn't protect anyone, it serves no purpose.</p>\n<p>Creating an empty contract just shifts responsibilities without offering real cushioning. In these scenarios, the additional cognitive cost doesn't pay off: the team needs to maintain redundant classes, search extra references, and deal with less direct diagnostics. Interfaces are tools, not ornaments. Using them outside relevant boundaries violates the very purpose of impact reduction.</p>\n<hr>\n<h2>When it's (very much) worth it</h2>\n<ul>\n<li>boundaries with databases and messaging systems</li>\n<li>integrations with external services</li>\n<li>inter-module or inter-domain communications</li>\n<li>architectural risk points</li>\n<li>where the cost of change is high or systemic</li>\n</ul>\n<p>If the interface protects the domain, it has already paid for itself.</p>\n<p>These points share a trait: they concentrate uncertainty and risk. An explicit contract allows introducing observability metrics in the adapter, applying resilience patterns (circuit breaker, retry, fallback), and testing the domain with test doubles that simulate extreme behaviors. Even a single implementation gains elasticity: alternative versions, additional instrumentation, or migration strategies can temporarily coexist under the same contract, without exponentially increasing entropy.</p>\n<hr>\n<h2>Decision checklist (use before creating)</h2>\n<p>| Question                                                  | If \"yes\", create interface |\n| --------------------------------------------------------- | -------------------------- |\n| Does this component touch something I don't control?      | Yes                        |\n| Might I need to update vendor, version, or stack?         | Yes                        |\n| If this dependency breaks, does the entire system suffer? | Yes                        |\n| Does this API expose too many details?                    | Yes                        |\n| Is there risk of impact beyond the current module?        | Yes                        |</p>\n<p>If everything is \"no\", don't create it.\nIf one is \"yes\", your interface already has a reason.</p>\n<p>This checklist acts as a conscious design exercise. It forces the team to reflect on responsibilities, boundaries, and impact before introducing or removing contracts. More importantly: it eliminates superficial discussions in code reviews, where criticism falls on the mere existence of the interface. The debate shifts to focus on concrete risk and necessary protection.</p>\n<hr>\n<h2>Executive summary</h2>\n<p>Interfaces aren't about the future.\nThey're about the cost of change <strong>today</strong>.</p>\n<p>Change doesn't only come from architectural decisions — swapping vendors, scaling teams, adding features. It also comes from entropy: runtime upgrades, deprecated APIs, security patches, framework evolution. Software rots not because teams fail, but because the world keeps moving around static code.</p>\n<p>The interface is the firewall between your domain logic and everything that changes without asking permission.</p>\n<p>That boundary pays for itself long before the second implementation ever appears.</p>\n<ul>\n<li>Don't create interfaces to inflate architecture.</li>\n<li>Don't create abstractions to win arguments in code reviews.</li>\n<li>Create contracts to protect boundaries and reduce impact.</li>\n</ul>\n<p>YAGNI isn't \"don't do it.\"\nYAGNI is <strong>\"don't do what protects nothing.\"</strong></p>"
    },
    "_id": "blog/pt/interfaces-arent-villains.md",
    "_raw": {
      "sourceFilePath": "blog/pt/interfaces-arent-villains.md",
      "sourceFileName": "interfaces-arent-villains.md",
      "sourceFileDir": "blog/pt",
      "contentType": "markdown",
      "flattenedPath": "blog/pt/interfaces-arent-villains"
    },
    "type": "Post",
    "locale": "pt",
    "slug": "interfaces-arent-villains",
    "url": "/blog/interfaces-arent-villains"
  },
  {
    "title": "Is learning coding really hard?",
    "description": "Spoiler: Learn how to code isn't hard. Its just a lot of work. And we usually confuse these two concepts.",
    "date": "2023-06-15T01:00:00.000Z",
    "author": "Josenaldo Matos",
    "category": "learning",
    "image": "/images/blog/learn-coding-is-not-hard.png",
    "body": {
      "raw": "\nIs it hard to learn coding well enough to become a professional developer?\n\nSpoiler: No. It's not hard. It's labor-intensive. And we often confuse these two concepts.\n\n## Your life isn't easy\n\nSo, you know nothing about coding. And your life seems like a complete mess! You might feel entirely overwhelmed.\n\nPerhaps you're dealing with numerous problems. Maybe you're working to pay the bills, or caring for your children or parents. Possibly, you're tending to your health or grappling with a severe health condition. You might be hungry, tired, sick, depressed, anxious, afraid, sad, angry, desperate, hopeless. The list seems endless.\n\nYes, it feels as though you're at the rock bottom of a deep pit.\n\nHere, you have two choices: stay or climb.\n\nI won't sugarcoat the truth: your situation seems severe and I don't possess a magic solution to dissolve your problems. My name is Josenaldo, not Jesus.\n\nWhat I can offer you, however, is a suggestion: learn to code.\n\n## Why Learn to Code?\n\nBecause you're financially challenged and it's a potential escape! It's a way to change your life, especially if you live in a country like Brazil, where the minimum wage may not cover your bills.\n\nYou don't need to love it. I'm not telling you how to become happy or how to find the meaning of life. I'm suggesting a survival strategy.\n\nYour task is to climb. After you've ascended, you can decide what to do with your life. But first, you must climb.\n\nIs it easy? No. But staying stagnant at the bottom of the pit is much harder.\n\nBecoming a developer is ONE pathway to change your life. And it's a FEASIBLE pathway.\n\n## What Do You Need to Start?\n\nThere are some essentials you'll need to begin:\n\n- A computer or a smartphone (if you're reading this, you likely have access to one of these)\n- Internet access\n- Time\n- Resilience\n\nSecuring a computer and internet access are perhaps the \"easiest\" items to acquire. If you don't have them, public libraries, a friend's house, or a café could provide access.\n\nHowever, when we start talking about time and resilience, things get a bit more complex.\n\n### Time and Resilience\n\nAcquiring a skill requires time - a lot of time. We're not talking about days or weeks here. We're talking about months, even years. This isn't a sprint; it's a marathon.\n\nI understand that this is a significant hurdle for many. But it's not impossible. All it requires is patience and persistence.\n\nBecoming a developer is akin to climbing a 200-story building using stairs.\n\nClimbing stairs seems easy enough, one step after another, right?\n\nBut climbing 200 stories requires enormous energy! And the degree of difficulty isn't the same for everyone.\n\nFor some, climbing just 2 floors is already a challenge, because they lack energy, or because they're hungry. For others, it's difficult because they don't have time, or because of some disability.\n\nBut, the question remains: despite these challenges, is it possible to climb 200 floors? Yes, it is.\n\n## How to Begin the Climb\n\nClimbing this building is labor-intensive, but it's accessible - far more than many others.\n\nTo gain entry into fields like medicine or law, for instance, the cost is so prohibitive that it's unattainable for most. You might not even make it past the door!\n\nYet, to enter the world of software development, you can essentially walk in for \"free\". The door is wide open, and all the steps are within your reach!\n\nHow so?\n\nAll the knowledge you need is available on the internet. EVERYTHING. And it's available at no cost. All you need to do is access it.\n\nThere are quality paid courses available. But if you have the funds for those, we likely don't need to continue this discussion.\n\nYou can access websites like Mozilla Developer Network, W3Schools, FreeCodeCamp, Codecademy, Udemy, YouTube, etc. Or you can learn using ChatGPT, a chatbot that can answer your questions about virtually anything.\n\nJust start! Choose one of these resources and begin! Start small, take baby steps, but start nonetheless!\n\n## How to Learn\n\nWhat is an self-taught person? It's a person who learns by himself, without a teacher, right?\n\nWrong.\n\nA self-taught person is a person who learns by himself, but with a lot of teachers.\n\nWhen you read a book, the book author become your teacher. When you watch a video, the video author become your teacher. When you read a blog post, the blog post author become your teacher.\n\nYou can learn from anyone, anywhere, anytime. You just have to be open to learn.\n\nTo learn how to code, you can use a lot of resources. You can read books, watch videos, read blog posts, listen to podcasts, etc. And, you NEED PRACTICE.\n\nThat the point where a lot of people get stuck or even give up. They dont practice. They just read, watch, listen, but they don't practice.\n\nCoding is a skill. And, like any other skill, the learning is based on two things:\n\n- Aquire the information (theory)\n- Train the skill (practice)\n\nTo learn the basics of how to programming, you will need about 200 hours. If you spend 4 hours a week, you'll need 50 weeks. It's almost a year!\n\n\"Then, if I study 4 hours a day, I'll be a developer in 50 days?\"\n\nNo. Your brain doesn't work in that way.\n\nIf you go to the gym, after years without lift any weight, and lift 200kg, you won't be a bodybuilder. You'll be dead.\n\nIf you try run a marathon without any training, you won't be a marathon runner. You'll hurt yourself.\n\nLearny how to code isn't different. You need to study and practice. And your body (specially your brain) needs time to adapt. You need to start small and go bigger.\n\nTherefore, your brain cannot absorve all the information at one time. You have limits on what you can learn in a day. Thats the reason why you need to study and practice every day. And why you need to REST.\n\n## How to practice\n\nTo learn how to code, you need to practice. But how?\n\nYou can practice by yourself, doing exercises, building projects, etc. But you can also practice with other people.\n\nYou can join a study group, a bootcamp, a course, a workshop, a hackathon, etc.\n\nYou can also practice by teaching. You can teach your friends, your family, your coworkers, etc.\n\n## Consistence\n\nThe key to learn how to code is consistence. You need to study and practice every day (or, at least, sometimes in a week). Even if you don't want to. Even if you are tired. Even if you are sad. Even if you are happy.\n\nLearn - Pratice - Rest. Repeat.\n\nWait... REST?\n\nYes. Rest is important. You need to rest. You need to SLEEP. You need to eat. You need to drink water. You need to exercise. You need to take care of yourself.\n\nRemember, this is a marathon, not a sprint!\n\nWithou the proper sleeping, for exemple, you can't learn. Your brain needs to rest to process the information you learned during the day. Sleep less can turn you dumber! Literaly!\n\n## Overall\n\nLearn how to code isn't hard. It's just hard-working. But it's possible. And it's worth it.\n\nIf you are in a bad situation, looking for a way out, look at this path. You can learn to code.\n\nYou don't need to like it. You just have to do it.\n\nScrewed, you're already. From the bottom of the pit, there's only one way up.\n",
      "html": "<p>Is it hard to learn coding well enough to become a professional developer?</p>\n<p>Spoiler: No. It's not hard. It's labor-intensive. And we often confuse these two concepts.</p>\n<h2>Your life isn't easy</h2>\n<p>So, you know nothing about coding. And your life seems like a complete mess! You might feel entirely overwhelmed.</p>\n<p>Perhaps you're dealing with numerous problems. Maybe you're working to pay the bills, or caring for your children or parents. Possibly, you're tending to your health or grappling with a severe health condition. You might be hungry, tired, sick, depressed, anxious, afraid, sad, angry, desperate, hopeless. The list seems endless.</p>\n<p>Yes, it feels as though you're at the rock bottom of a deep pit.</p>\n<p>Here, you have two choices: stay or climb.</p>\n<p>I won't sugarcoat the truth: your situation seems severe and I don't possess a magic solution to dissolve your problems. My name is Josenaldo, not Jesus.</p>\n<p>What I can offer you, however, is a suggestion: learn to code.</p>\n<h2>Why Learn to Code?</h2>\n<p>Because you're financially challenged and it's a potential escape! It's a way to change your life, especially if you live in a country like Brazil, where the minimum wage may not cover your bills.</p>\n<p>You don't need to love it. I'm not telling you how to become happy or how to find the meaning of life. I'm suggesting a survival strategy.</p>\n<p>Your task is to climb. After you've ascended, you can decide what to do with your life. But first, you must climb.</p>\n<p>Is it easy? No. But staying stagnant at the bottom of the pit is much harder.</p>\n<p>Becoming a developer is ONE pathway to change your life. And it's a FEASIBLE pathway.</p>\n<h2>What Do You Need to Start?</h2>\n<p>There are some essentials you'll need to begin:</p>\n<ul>\n<li>A computer or a smartphone (if you're reading this, you likely have access to one of these)</li>\n<li>Internet access</li>\n<li>Time</li>\n<li>Resilience</li>\n</ul>\n<p>Securing a computer and internet access are perhaps the \"easiest\" items to acquire. If you don't have them, public libraries, a friend's house, or a café could provide access.</p>\n<p>However, when we start talking about time and resilience, things get a bit more complex.</p>\n<h3>Time and Resilience</h3>\n<p>Acquiring a skill requires time - a lot of time. We're not talking about days or weeks here. We're talking about months, even years. This isn't a sprint; it's a marathon.</p>\n<p>I understand that this is a significant hurdle for many. But it's not impossible. All it requires is patience and persistence.</p>\n<p>Becoming a developer is akin to climbing a 200-story building using stairs.</p>\n<p>Climbing stairs seems easy enough, one step after another, right?</p>\n<p>But climbing 200 stories requires enormous energy! And the degree of difficulty isn't the same for everyone.</p>\n<p>For some, climbing just 2 floors is already a challenge, because they lack energy, or because they're hungry. For others, it's difficult because they don't have time, or because of some disability.</p>\n<p>But, the question remains: despite these challenges, is it possible to climb 200 floors? Yes, it is.</p>\n<h2>How to Begin the Climb</h2>\n<p>Climbing this building is labor-intensive, but it's accessible - far more than many others.</p>\n<p>To gain entry into fields like medicine or law, for instance, the cost is so prohibitive that it's unattainable for most. You might not even make it past the door!</p>\n<p>Yet, to enter the world of software development, you can essentially walk in for \"free\". The door is wide open, and all the steps are within your reach!</p>\n<p>How so?</p>\n<p>All the knowledge you need is available on the internet. EVERYTHING. And it's available at no cost. All you need to do is access it.</p>\n<p>There are quality paid courses available. But if you have the funds for those, we likely don't need to continue this discussion.</p>\n<p>You can access websites like Mozilla Developer Network, W3Schools, FreeCodeCamp, Codecademy, Udemy, YouTube, etc. Or you can learn using ChatGPT, a chatbot that can answer your questions about virtually anything.</p>\n<p>Just start! Choose one of these resources and begin! Start small, take baby steps, but start nonetheless!</p>\n<h2>How to Learn</h2>\n<p>What is an self-taught person? It's a person who learns by himself, without a teacher, right?</p>\n<p>Wrong.</p>\n<p>A self-taught person is a person who learns by himself, but with a lot of teachers.</p>\n<p>When you read a book, the book author become your teacher. When you watch a video, the video author become your teacher. When you read a blog post, the blog post author become your teacher.</p>\n<p>You can learn from anyone, anywhere, anytime. You just have to be open to learn.</p>\n<p>To learn how to code, you can use a lot of resources. You can read books, watch videos, read blog posts, listen to podcasts, etc. And, you NEED PRACTICE.</p>\n<p>That the point where a lot of people get stuck or even give up. They dont practice. They just read, watch, listen, but they don't practice.</p>\n<p>Coding is a skill. And, like any other skill, the learning is based on two things:</p>\n<ul>\n<li>Aquire the information (theory)</li>\n<li>Train the skill (practice)</li>\n</ul>\n<p>To learn the basics of how to programming, you will need about 200 hours. If you spend 4 hours a week, you'll need 50 weeks. It's almost a year!</p>\n<p>\"Then, if I study 4 hours a day, I'll be a developer in 50 days?\"</p>\n<p>No. Your brain doesn't work in that way.</p>\n<p>If you go to the gym, after years without lift any weight, and lift 200kg, you won't be a bodybuilder. You'll be dead.</p>\n<p>If you try run a marathon without any training, you won't be a marathon runner. You'll hurt yourself.</p>\n<p>Learny how to code isn't different. You need to study and practice. And your body (specially your brain) needs time to adapt. You need to start small and go bigger.</p>\n<p>Therefore, your brain cannot absorve all the information at one time. You have limits on what you can learn in a day. Thats the reason why you need to study and practice every day. And why you need to REST.</p>\n<h2>How to practice</h2>\n<p>To learn how to code, you need to practice. But how?</p>\n<p>You can practice by yourself, doing exercises, building projects, etc. But you can also practice with other people.</p>\n<p>You can join a study group, a bootcamp, a course, a workshop, a hackathon, etc.</p>\n<p>You can also practice by teaching. You can teach your friends, your family, your coworkers, etc.</p>\n<h2>Consistence</h2>\n<p>The key to learn how to code is consistence. You need to study and practice every day (or, at least, sometimes in a week). Even if you don't want to. Even if you are tired. Even if you are sad. Even if you are happy.</p>\n<p>Learn - Pratice - Rest. Repeat.</p>\n<p>Wait... REST?</p>\n<p>Yes. Rest is important. You need to rest. You need to SLEEP. You need to eat. You need to drink water. You need to exercise. You need to take care of yourself.</p>\n<p>Remember, this is a marathon, not a sprint!</p>\n<p>Withou the proper sleeping, for exemple, you can't learn. Your brain needs to rest to process the information you learned during the day. Sleep less can turn you dumber! Literaly!</p>\n<h2>Overall</h2>\n<p>Learn how to code isn't hard. It's just hard-working. But it's possible. And it's worth it.</p>\n<p>If you are in a bad situation, looking for a way out, look at this path. You can learn to code.</p>\n<p>You don't need to like it. You just have to do it.</p>\n<p>Screwed, you're already. From the bottom of the pit, there's only one way up.</p>"
    },
    "_id": "blog/pt/learn-coding-is-not-hard.md",
    "_raw": {
      "sourceFilePath": "blog/pt/learn-coding-is-not-hard.md",
      "sourceFileName": "learn-coding-is-not-hard.md",
      "sourceFileDir": "blog/pt",
      "contentType": "markdown",
      "flattenedPath": "blog/pt/learn-coding-is-not-hard"
    },
    "type": "Post",
    "locale": "pt",
    "slug": "learn-coding-is-not-hard",
    "url": "/blog/learn-coding-is-not-hard"
  },
  {
    "title": "The return of the Jedi",
    "description": "This post marks the beginning of a new journey in my life: my fight for my return to the world of software development.",
    "date": "2023-04-15T01:00:00.000Z",
    "author": "Josenaldo Matos",
    "category": "personal",
    "image": "/images/blog/return-of-the-jedi.png",
    "body": {
      "raw": "\nHello, everyone! My name is Josenaldo Matos, and I'm incredibly excited to be launching my new blog, Nephro Nerd Chronicles. This first post is about how I'm embarking on a journey to return to work after a long and challenging period in my life.\n\nI've been working in software development since 1999, and I'm passionate about creating web applications, especially using Java and JavaScript. However, my life took an unexpected turn in 2008 when I lost my kidney function and had to start hemodialysis. Through the years, I've had to overcome many obstacles, including a kidney transplant, multiple accidents, and the loss of a loved one.\n\nDespite these challenges, I've always remained passionate about software development and have continued learning new technologies. My motivation for returning to work is twofold: I love the satisfaction of solving problems and creating useful tools, and I need to support my family and achieve our dreams.\n\nCurrently, I face some difficulties due to my health and hemodialysis schedule, but I'm determined not to let these obstacles stand in my way. My goal is to find a job that allows me to be productive, create value, and earn a good income without jeopardizing my health.\n\nLooking ahead, I envision a future where I can provide a better life for my family and myself by creating a comfortable and productive home environment. Through hard work and determination, I believe that I can overcome the challenges I face and achieve success in both my personal and professional life.\n\nThank you for joining me on this journey, and I look forward to sharing more about my experiences, interests, and the world of software development here on Nephro Nerd Chronicles. Stay tuned for more posts, and feel free to reach out if you have any questions or suggestions.\n\nLet the adventure begin!\n",
      "html": "<p>Hello, everyone! My name is Josenaldo Matos, and I'm incredibly excited to be launching my new blog, Nephro Nerd Chronicles. This first post is about how I'm embarking on a journey to return to work after a long and challenging period in my life.</p>\n<p>I've been working in software development since 1999, and I'm passionate about creating web applications, especially using Java and JavaScript. However, my life took an unexpected turn in 2008 when I lost my kidney function and had to start hemodialysis. Through the years, I've had to overcome many obstacles, including a kidney transplant, multiple accidents, and the loss of a loved one.</p>\n<p>Despite these challenges, I've always remained passionate about software development and have continued learning new technologies. My motivation for returning to work is twofold: I love the satisfaction of solving problems and creating useful tools, and I need to support my family and achieve our dreams.</p>\n<p>Currently, I face some difficulties due to my health and hemodialysis schedule, but I'm determined not to let these obstacles stand in my way. My goal is to find a job that allows me to be productive, create value, and earn a good income without jeopardizing my health.</p>\n<p>Looking ahead, I envision a future where I can provide a better life for my family and myself by creating a comfortable and productive home environment. Through hard work and determination, I believe that I can overcome the challenges I face and achieve success in both my personal and professional life.</p>\n<p>Thank you for joining me on this journey, and I look forward to sharing more about my experiences, interests, and the world of software development here on Nephro Nerd Chronicles. Stay tuned for more posts, and feel free to reach out if you have any questions or suggestions.</p>\n<p>Let the adventure begin!</p>"
    },
    "_id": "blog/pt/return-of-the-jedi.md",
    "_raw": {
      "sourceFilePath": "blog/pt/return-of-the-jedi.md",
      "sourceFileName": "return-of-the-jedi.md",
      "sourceFileDir": "blog/pt",
      "contentType": "markdown",
      "flattenedPath": "blog/pt/return-of-the-jedi"
    },
    "type": "Post",
    "locale": "pt",
    "slug": "return-of-the-jedi",
    "url": "/blog/return-of-the-jedi"
  },
  {
    "title": "Why am I still invisible?",
    "description": "Why, despite being qualified, am I still invisible to the job market?",
    "date": "2024-08-01T01:00:00.000Z",
    "author": "Josenaldo Matos",
    "category": "job-market",
    "image": "/images/blog/why-am-i-still-invisible.png",
    "body": {
      "raw": "\nI saw [this LinkedIn post by Pablo Jorge Maciel](https://www.linkedin.com/posts/pjmaciel_um-desabafo-sobre-a-ti-e-o-tech-recruiter-activity-7224531473201037313-_KIJ), where he vents and questions why, despite being qualified, he's still invisible to the job market. I related strongly to what he said. So I decided to write this post to share my thoughts on the subject with you.\n\nThere are two ways to get a job: hunting and farming.\n\nI saw this definition on Twitter (_I'll never call it X_), in this thread by [@SergioRocks](https://x.com/SergioRocks/status/1811386383258272092), and I thought it was really good.\n\nHunting is when you actively go after work. It's when you send your resume, when you apply. It's when you network, when you go to events, when you introduce yourself. It's when you cold call, when you message on LinkedIn. It's when you interview, when you take tests. It's when you chase it down.\n\nFarming is when you \"cultivate\" good relationships and reputation until the fruits start falling at your feet and you start being called, referred, and invited. Sounds good, right?\n\nThe problem is that farming takes time and considerable effort. This means we have to rely much more on hunting in the short term than on farming. This emphasis on hunting can lead to forgetting farming practices, resulting in invisibility in the job market.\n\n## The problem with hunting\n\nHunting seems to offer more immediate results, but it takes a lot of work, consumes a lot of time, and the return rate is ridiculously low.\n\nThe practice of hunting can be compared to selling a product to individuals who don't know the seller: it's a numbers game and you're going to send your resume to MANY job openings. A LOT. In the hundreds. Maybe even thousands. And you'll do this knowing you'll get a pitiful return.\n\nAnd why is it like this? Because the hunting sales funnel is cruel.\n\n### The hunting sales funnel\n\nWe can say that hunting is a sales funnel. And, like any sales funnel, it has several stages and has a conversion rate. The issue here is that the hunting conversion rate, by nature, is very low.\n\nFor starters, a significant portion of job postings are ghost positions. Your resume won't even be read. There isn't even anyone on the other side. This position was created to meet a quota, to justify a budget, to create volume, or to give the impression that the company is growing. And you have no way of knowing which ones these are.\n\nOf those remaining, the ones that aren't ghosts, you probably won't get past the ATS automated screening stage. Yes, an AI will block you, because it can't read your resume, especially if it has columns, decorations, and embellishments. In this regard, the simpler the resume layout, the better. Avoid using columns, tables, graphs, images, icons, colors, different fonts, etc. It's also recommended to use file formats easily readable by artificial intelligence systems, such as .docx or PDF. Check out [my GitHub for a resume example I use](https://github.com/josenaldo). Feel free to download and use it.\n\nIn the next stage, you fight against time. If you apply for a position that received hundreds of applications, do you really think the recruitment team, with tight deadlines and few available people, will have time to read all the selected ones? If you arrived at the end of the line, the chance of even being seen is high.\n\nIn short, your chance of finding a real position, being selected by the ATS, being seen by the recruiter, and being called for an interview is very low. And if you reach this stage, you'll still have to go through the gauntlet to prove you're good enough and better than other candidates.\n\n### How to beat this funnel?\n\nPatience, determination, resilience, persistence, and NUMBERS.\n\nThere's lots of advice out there, but I'll summarize here:\n\n- Simplify your resume\n- Prefer ATS-compatible file formats, like PDF\n- Focus on positions well-aligned with your skills\n- Give preference to:\n    - more recent positions (the chance of old positions being ghosts is higher)\n    - positions with fewer applications (the chance of being seen is higher)\n- Apply to as many positions as possible. Keep sending resumes until your email provider starts suspecting you're trying to communicate with another planet.\n\nThere's not much way around it. If you need to find a job, you're going to have to sweat. However, while hunting is essential for an active and immediate search for opportunities, it shouldn't be the only strategy adopted.\n\n## And farming?\n\nSo... You don't want to spend the rest of your life hunting, right?\n\nWhile hunting may seem like the most straightforward strategy for entering the job market, it's important to recognize the value of farming. The latter can be seen as a long-term investment in your career. By cultivating relationships and building a solid reputation, you establish fertile ground that, over time, will bring opportunities to you more naturally and frequently. Thus, while hunting seeks immediate results, farming paves the way for future and sustainable opportunities. Therefore, let's plant!\n\nBut what exactly does 'planting' mean in the context of employability?\n\nThink of your career as a garden that needs to be cared for and cultivated to flourish. Just like a garden, your professional trajectory doesn't grow by chance; it requires attention, planning, and continuous care.\n\nImagine your work is like growing food: instead of depending on sporadic hunting trips, which can be uncertain and inconsistent, you develop a fertile field. This field, carefully maintained, begins to produce food regularly, providing a sustainable and reliable source of nutrition.\n\nHow do you apply this metaphor to your professional life?\n\nYou 'plant' by building and cultivating your reputation and your network.\n\n- **Cultivating your reputation**: This is about demonstrating your competence and reliability through consistent, high-quality work. Each successfully completed project, each positive feedback, and each innovative solution you offer are like seeds germinating in your professional field.\n- **Expanding your network**: Relating to other professionals is like watering and nourishing the soil. Participating in industry events, interacting on professional social media platforms, and collaborating on projects are ways to keep your 'field' healthy and productive. Each connection is a root that deepens into the soil of your career, bringing stability and opening new paths for opportunities.\n\nHere, patience is crucial. Just as a field doesn't produce an immediate harvest, networking and building a solid reputation take time and persistence. But once established, they provide valuable resources that can sustain your career for many years.\n\n### Cultivating your reputation in IT\n\nIn the IT field, reputation is intangible capital, but of invaluable worth. It functions as a currency in the vast technology job market, where professionals are continuously evaluated for their competencies and integrity. Being recognized as a good professional can open doors and facilitate recommendations; on the other hand, a negative reputation can create almost insurmountable barriers.\n\n#### Investing in building a solid reputation\n\n- **Consistent Quality**: The foundation of a good reputation starts with the consistent delivery of quality work. In IT, this means writing clean code, properly documenting your projects, and meeting deadlines. Every detail counts when your work is under scrutiny.\n- **Problem Solving**: Stand out as someone who not only identifies problems but who brings effective solutions. The ability to solve challenges creatively and efficiently is highly valued in the dynamic IT environment.\n- **Continuous Learning**: The technology field is always evolving, and staying updated with the latest technologies and practices is fundamental. Participating in courses, workshops, and seminars not only expands your knowledge but also demonstrates your commitment to self-development.\n- **Collaboration and Communication**: IT frequently involves teamwork. Being a team player who communicates clearly and contributes to collective success strengthens your reputation as someone reliable and collaborative.\n\n#### Building your sphere of influence\n\n- **Effective Networking**: Attend industry events, join professional groups, and interact on digital platforms specific to IT professionals. These spaces are ideal for demonstrating your expertise and learning from others.\n- **Contributions and Participation**: Contribute to open-source projects, publish articles about your areas of expertise, and participate in discussion forums. These activities put your name in circulation within the technology community and contribute to an image of an engaged and active professional.\n- **Feedback and Endorsements**: Ask for feedback regularly and accept constructive criticism. Endorsements from colleagues and superiors on platforms like LinkedIn can also validate your skills and strengthen your reputation.\n\nRemember that building a reputation takes time and requires continuous effort. You don't need to be a digital influencer or a technology genius, but it's crucial that your peers and industry leaders trust your ability to deliver results and contribute positively. By cultivating your reputation daily, you sow the seeds for a lasting and rewarding career in IT.\n\n### The empty field problem\n\nMany professionals at the beginning of their careers face a common dilemma: the lack of reputation and network. Without an established work history, they find themselves in what can be described as a \"catch-22\" — they don't have a reputation because they don't have work, and they can't get work because they don't have a reputation.\n\n#### Breaking the cycle\n\nTo overcome this challenge, it's crucial to understand that your reputation is intrinsically linked to your results. If traditional results aren't yet an option, you need to create opportunities for yourself.\n\n**If you chose the academic path**\n\nYou don't go to college to make friends, but to become a qualified professional. Therefore, make the most of your academic experience.\n\n- **Internships**: Actively seek internship opportunities, even if they're not initially paid. These are gateways to practical experience.\n- **Networking at college**: Engage with colleagues and professors. Being active in academic projects and study groups can also increase your visibility.\n- **Professional attitude**: Show yourself as helpful, collaborative, and reliable. The way you interact with others and your willingness to help can create a lasting impression.\n\n**For self-taught learners**\n\nIf you went the self-taught route, start by praying for luck. And while it doesn't come, learn, produce, and participate.\n\n- **Continuous education**: Invest in online courses, workshops, and bootcamps that offer recognizable credentials. Prioritize those that provide practical skills and portfolio projects.\n- **Personal and open-source projects**: Contribute to open-source projects or develop your own projects. This not only shows your technical capability but also your initiative and passion for the field.\n- **Visibility at events**: Actively participate in meetups, conferences, and IT seminars. Every interaction is an opportunity to build your network.\n\n**For professionals between jobs**\n\n- **Analysis and reflection**: Review your previous work experiences. Identify areas for improvement and seek resources to develop these skills.\n- **Stay active**: Continue applying what you've learned and sharing your knowledge. Blogs, video tutorials, and forum participation can keep your market presence warm.\n- **Networking**: Keep in touch with former colleagues, professors, and mentors. They can be valuable sources of references and future opportunities.\n\n**For Employed Professionals**\n\nRemember that your career is the priority, even while contributing to company goals. Each task and challenge not only advances the organization but also strengthens your professional trajectory. Take responsibility for developing your career to ensure long-term success.\n\nCultivate your work environment:\n\n- **Build Relationships**: Maintain good relationships with colleagues and managers and demonstrate leadership, regardless of your position.\n- **Work Ethic**: Be known for your ethics and team spirit, which can open doors to future opportunities.\n\nAdopt continuous development:\n\n- **Constant Education**: Invest in learning new technologies and trends, participating in relevant courses and certifications.\n- **Feedback and Self-Assessment**: Request feedback regularly and use it to direct your personal development.\n\nBy implementing these practices, you not only advance in your career but also contribute significantly to the success of the team and the company.\n\n## Conclusion\n\nTranscending invisibility in the job market is a considerable challenge, but absolutely achievable. A well-cultivated career can become a continuous source of opportunities. For this, it's essential to invest daily in your professional development.\n\nCultivate, plant, and prosper in your professional trajectory, transforming each action into a step from shadow toward realization and success.\n\nWhile awaiting the results of these efforts, stay active in hunting for new opportunities — pursue them with determination and tenacity, as if your life depended on it. Because, in fact, it does.\n",
      "html": "<p>I saw <a href=\"https://www.linkedin.com/posts/pjmaciel_um-desabafo-sobre-a-ti-e-o-tech-recruiter-activity-7224531473201037313-_KIJ\">this LinkedIn post by Pablo Jorge Maciel</a>, where he vents and questions why, despite being qualified, he's still invisible to the job market. I related strongly to what he said. So I decided to write this post to share my thoughts on the subject with you.</p>\n<p>There are two ways to get a job: hunting and farming.</p>\n<p>I saw this definition on Twitter (<em>I'll never call it X</em>), in this thread by <a href=\"https://x.com/SergioRocks/status/1811386383258272092\">@SergioRocks</a>, and I thought it was really good.</p>\n<p>Hunting is when you actively go after work. It's when you send your resume, when you apply. It's when you network, when you go to events, when you introduce yourself. It's when you cold call, when you message on LinkedIn. It's when you interview, when you take tests. It's when you chase it down.</p>\n<p>Farming is when you \"cultivate\" good relationships and reputation until the fruits start falling at your feet and you start being called, referred, and invited. Sounds good, right?</p>\n<p>The problem is that farming takes time and considerable effort. This means we have to rely much more on hunting in the short term than on farming. This emphasis on hunting can lead to forgetting farming practices, resulting in invisibility in the job market.</p>\n<h2>The problem with hunting</h2>\n<p>Hunting seems to offer more immediate results, but it takes a lot of work, consumes a lot of time, and the return rate is ridiculously low.</p>\n<p>The practice of hunting can be compared to selling a product to individuals who don't know the seller: it's a numbers game and you're going to send your resume to MANY job openings. A LOT. In the hundreds. Maybe even thousands. And you'll do this knowing you'll get a pitiful return.</p>\n<p>And why is it like this? Because the hunting sales funnel is cruel.</p>\n<h3>The hunting sales funnel</h3>\n<p>We can say that hunting is a sales funnel. And, like any sales funnel, it has several stages and has a conversion rate. The issue here is that the hunting conversion rate, by nature, is very low.</p>\n<p>For starters, a significant portion of job postings are ghost positions. Your resume won't even be read. There isn't even anyone on the other side. This position was created to meet a quota, to justify a budget, to create volume, or to give the impression that the company is growing. And you have no way of knowing which ones these are.</p>\n<p>Of those remaining, the ones that aren't ghosts, you probably won't get past the ATS automated screening stage. Yes, an AI will block you, because it can't read your resume, especially if it has columns, decorations, and embellishments. In this regard, the simpler the resume layout, the better. Avoid using columns, tables, graphs, images, icons, colors, different fonts, etc. It's also recommended to use file formats easily readable by artificial intelligence systems, such as .docx or PDF. Check out <a href=\"https://github.com/josenaldo\">my GitHub for a resume example I use</a>. Feel free to download and use it.</p>\n<p>In the next stage, you fight against time. If you apply for a position that received hundreds of applications, do you really think the recruitment team, with tight deadlines and few available people, will have time to read all the selected ones? If you arrived at the end of the line, the chance of even being seen is high.</p>\n<p>In short, your chance of finding a real position, being selected by the ATS, being seen by the recruiter, and being called for an interview is very low. And if you reach this stage, you'll still have to go through the gauntlet to prove you're good enough and better than other candidates.</p>\n<h3>How to beat this funnel?</h3>\n<p>Patience, determination, resilience, persistence, and NUMBERS.</p>\n<p>There's lots of advice out there, but I'll summarize here:</p>\n<ul>\n<li>Simplify your resume</li>\n<li>Prefer ATS-compatible file formats, like PDF</li>\n<li>Focus on positions well-aligned with your skills</li>\n<li>Give preference to:\n<ul>\n<li>more recent positions (the chance of old positions being ghosts is higher)</li>\n<li>positions with fewer applications (the chance of being seen is higher)</li>\n</ul>\n</li>\n<li>Apply to as many positions as possible. Keep sending resumes until your email provider starts suspecting you're trying to communicate with another planet.</li>\n</ul>\n<p>There's not much way around it. If you need to find a job, you're going to have to sweat. However, while hunting is essential for an active and immediate search for opportunities, it shouldn't be the only strategy adopted.</p>\n<h2>And farming?</h2>\n<p>So... You don't want to spend the rest of your life hunting, right?</p>\n<p>While hunting may seem like the most straightforward strategy for entering the job market, it's important to recognize the value of farming. The latter can be seen as a long-term investment in your career. By cultivating relationships and building a solid reputation, you establish fertile ground that, over time, will bring opportunities to you more naturally and frequently. Thus, while hunting seeks immediate results, farming paves the way for future and sustainable opportunities. Therefore, let's plant!</p>\n<p>But what exactly does 'planting' mean in the context of employability?</p>\n<p>Think of your career as a garden that needs to be cared for and cultivated to flourish. Just like a garden, your professional trajectory doesn't grow by chance; it requires attention, planning, and continuous care.</p>\n<p>Imagine your work is like growing food: instead of depending on sporadic hunting trips, which can be uncertain and inconsistent, you develop a fertile field. This field, carefully maintained, begins to produce food regularly, providing a sustainable and reliable source of nutrition.</p>\n<p>How do you apply this metaphor to your professional life?</p>\n<p>You 'plant' by building and cultivating your reputation and your network.</p>\n<ul>\n<li><strong>Cultivating your reputation</strong>: This is about demonstrating your competence and reliability through consistent, high-quality work. Each successfully completed project, each positive feedback, and each innovative solution you offer are like seeds germinating in your professional field.</li>\n<li><strong>Expanding your network</strong>: Relating to other professionals is like watering and nourishing the soil. Participating in industry events, interacting on professional social media platforms, and collaborating on projects are ways to keep your 'field' healthy and productive. Each connection is a root that deepens into the soil of your career, bringing stability and opening new paths for opportunities.</li>\n</ul>\n<p>Here, patience is crucial. Just as a field doesn't produce an immediate harvest, networking and building a solid reputation take time and persistence. But once established, they provide valuable resources that can sustain your career for many years.</p>\n<h3>Cultivating your reputation in IT</h3>\n<p>In the IT field, reputation is intangible capital, but of invaluable worth. It functions as a currency in the vast technology job market, where professionals are continuously evaluated for their competencies and integrity. Being recognized as a good professional can open doors and facilitate recommendations; on the other hand, a negative reputation can create almost insurmountable barriers.</p>\n<h4>Investing in building a solid reputation</h4>\n<ul>\n<li><strong>Consistent Quality</strong>: The foundation of a good reputation starts with the consistent delivery of quality work. In IT, this means writing clean code, properly documenting your projects, and meeting deadlines. Every detail counts when your work is under scrutiny.</li>\n<li><strong>Problem Solving</strong>: Stand out as someone who not only identifies problems but who brings effective solutions. The ability to solve challenges creatively and efficiently is highly valued in the dynamic IT environment.</li>\n<li><strong>Continuous Learning</strong>: The technology field is always evolving, and staying updated with the latest technologies and practices is fundamental. Participating in courses, workshops, and seminars not only expands your knowledge but also demonstrates your commitment to self-development.</li>\n<li><strong>Collaboration and Communication</strong>: IT frequently involves teamwork. Being a team player who communicates clearly and contributes to collective success strengthens your reputation as someone reliable and collaborative.</li>\n</ul>\n<h4>Building your sphere of influence</h4>\n<ul>\n<li><strong>Effective Networking</strong>: Attend industry events, join professional groups, and interact on digital platforms specific to IT professionals. These spaces are ideal for demonstrating your expertise and learning from others.</li>\n<li><strong>Contributions and Participation</strong>: Contribute to open-source projects, publish articles about your areas of expertise, and participate in discussion forums. These activities put your name in circulation within the technology community and contribute to an image of an engaged and active professional.</li>\n<li><strong>Feedback and Endorsements</strong>: Ask for feedback regularly and accept constructive criticism. Endorsements from colleagues and superiors on platforms like LinkedIn can also validate your skills and strengthen your reputation.</li>\n</ul>\n<p>Remember that building a reputation takes time and requires continuous effort. You don't need to be a digital influencer or a technology genius, but it's crucial that your peers and industry leaders trust your ability to deliver results and contribute positively. By cultivating your reputation daily, you sow the seeds for a lasting and rewarding career in IT.</p>\n<h3>The empty field problem</h3>\n<p>Many professionals at the beginning of their careers face a common dilemma: the lack of reputation and network. Without an established work history, they find themselves in what can be described as a \"catch-22\" — they don't have a reputation because they don't have work, and they can't get work because they don't have a reputation.</p>\n<h4>Breaking the cycle</h4>\n<p>To overcome this challenge, it's crucial to understand that your reputation is intrinsically linked to your results. If traditional results aren't yet an option, you need to create opportunities for yourself.</p>\n<p><strong>If you chose the academic path</strong></p>\n<p>You don't go to college to make friends, but to become a qualified professional. Therefore, make the most of your academic experience.</p>\n<ul>\n<li><strong>Internships</strong>: Actively seek internship opportunities, even if they're not initially paid. These are gateways to practical experience.</li>\n<li><strong>Networking at college</strong>: Engage with colleagues and professors. Being active in academic projects and study groups can also increase your visibility.</li>\n<li><strong>Professional attitude</strong>: Show yourself as helpful, collaborative, and reliable. The way you interact with others and your willingness to help can create a lasting impression.</li>\n</ul>\n<p><strong>For self-taught learners</strong></p>\n<p>If you went the self-taught route, start by praying for luck. And while it doesn't come, learn, produce, and participate.</p>\n<ul>\n<li><strong>Continuous education</strong>: Invest in online courses, workshops, and bootcamps that offer recognizable credentials. Prioritize those that provide practical skills and portfolio projects.</li>\n<li><strong>Personal and open-source projects</strong>: Contribute to open-source projects or develop your own projects. This not only shows your technical capability but also your initiative and passion for the field.</li>\n<li><strong>Visibility at events</strong>: Actively participate in meetups, conferences, and IT seminars. Every interaction is an opportunity to build your network.</li>\n</ul>\n<p><strong>For professionals between jobs</strong></p>\n<ul>\n<li><strong>Analysis and reflection</strong>: Review your previous work experiences. Identify areas for improvement and seek resources to develop these skills.</li>\n<li><strong>Stay active</strong>: Continue applying what you've learned and sharing your knowledge. Blogs, video tutorials, and forum participation can keep your market presence warm.</li>\n<li><strong>Networking</strong>: Keep in touch with former colleagues, professors, and mentors. They can be valuable sources of references and future opportunities.</li>\n</ul>\n<p><strong>For Employed Professionals</strong></p>\n<p>Remember that your career is the priority, even while contributing to company goals. Each task and challenge not only advances the organization but also strengthens your professional trajectory. Take responsibility for developing your career to ensure long-term success.</p>\n<p>Cultivate your work environment:</p>\n<ul>\n<li><strong>Build Relationships</strong>: Maintain good relationships with colleagues and managers and demonstrate leadership, regardless of your position.</li>\n<li><strong>Work Ethic</strong>: Be known for your ethics and team spirit, which can open doors to future opportunities.</li>\n</ul>\n<p>Adopt continuous development:</p>\n<ul>\n<li><strong>Constant Education</strong>: Invest in learning new technologies and trends, participating in relevant courses and certifications.</li>\n<li><strong>Feedback and Self-Assessment</strong>: Request feedback regularly and use it to direct your personal development.</li>\n</ul>\n<p>By implementing these practices, you not only advance in your career but also contribute significantly to the success of the team and the company.</p>\n<h2>Conclusion</h2>\n<p>Transcending invisibility in the job market is a considerable challenge, but absolutely achievable. A well-cultivated career can become a continuous source of opportunities. For this, it's essential to invest daily in your professional development.</p>\n<p>Cultivate, plant, and prosper in your professional trajectory, transforming each action into a step from shadow toward realization and success.</p>\n<p>While awaiting the results of these efforts, stay active in hunting for new opportunities — pursue them with determination and tenacity, as if your life depended on it. Because, in fact, it does.</p>"
    },
    "_id": "blog/pt/why-am-i-still-invisible.md",
    "_raw": {
      "sourceFilePath": "blog/pt/why-am-i-still-invisible.md",
      "sourceFileName": "why-am-i-still-invisible.md",
      "sourceFileDir": "blog/pt",
      "contentType": "markdown",
      "flattenedPath": "blog/pt/why-am-i-still-invisible"
    },
    "type": "Post",
    "locale": "pt",
    "slug": "why-am-i-still-invisible",
    "url": "/blog/why-am-i-still-invisible"
  }
]